From c08d525e6bae2b49d0d86f4dc936d17d5bc6693b Mon Sep 17 00:00:00 2001
From: tomasz-karczewski-red <tomasz.karczewski@redembedded.com>
Date: Tue, 21 Nov 2023 14:44:54 +0100
Subject: [PATCH] ONEM-32873 OCDM CBCS Playready implementation on eos2008c

cbcs implementation in BRCM_REFSWSecurity_PRDY_3_0_HostLib_URSR_19_2_2_LGI_E1_20201208 doesn't
accept blocks that are not aligned in size to multiples of 16 bytes. The modulo_16 part at the end
of such block is unencrypted - so we need to split eg.
[335 encrypted ,0 clear] block into two blocks like: [320 enc,0 clear],[0 enc,15 clear]

see: https://brcmsemiconductor-csm.wolkenservicedesk.com/wolken-support/mycases/request-details?requestId=123232
Change-Id: Ic60993f9649da73f045cc9f535b8a44038ca6b85
---
 open_cdm_adapter.cpp | 51 ++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 51 insertions(+)

diff --git a/open_cdm_adapter.cpp b/open_cdm_adapter.cpp
index a84c85e..d2c17c8 100644
--- a/Source/ocdm/adapter/broadcom-svp/open_cdm_adapter.cpp
+++ b/Source/ocdm/adapter/broadcom-svp/open_cdm_adapter.cpp
@@ -70,6 +70,51 @@ inline bool mappedBuffer(GstBuffer *buffer, bool writable, uint8_t **data, uint3
     return true;
 }
 
+#ifdef PLAYREADY_CBCS_URSR_19_2_2_ALIGN_16_FIX
+/*
+    ONEM-33069: cbcs implementation in BRCM_REFSWSecurity_PRDY_3_0_HostLib_URSR_19_2_2_LGI_E1_20201208 doesn't
+    accept blocks that are not aligned in size to multiples of 16 bytes. The modulo_16 part at the end of such block is
+    unencrypted - so correct_chunks_in_svp_meta will split eg. [335 encrypted ,0 clear] block
+    into two blocks like: [320 enc,0 clear],[0 enc,15 clear]
+    here it is only applied at brcm_svp_meta_data_t info level; similar thing needs to be done in OCDM-Playready-Nexus-SVP
+    where the actual decryption takes place.
+    see: https://brcmsemiconductor-csm.wolkenservicedesk.com/wolken-support/mycases/request-details?requestId=12323254
+*/
+static void correct_chunks_in_svp_meta_for_cbcs(brcm_svp_meta_data_t* svpMeta) {
+    std::vector<std::tuple<unsigned,unsigned,unsigned>> alignedChunks;
+    for (size_t position = 0; position < svpMeta->u.u3.chunks_cnt; ++position) {
+        if (svpMeta->u.u3.chunk_info[position].encrypted_size & 0xF) {
+            // need to split this into 2 blocks
+            alignedChunks.push_back({
+                svpMeta->u.u3.chunk_info[position].clear_size,
+                svpMeta->u.u3.chunk_info[position].encrypted_size & ~0xF,
+                svpMeta->u.u3.chunk_info[position].offset});
+            alignedChunks.push_back({
+                svpMeta->u.u3.chunk_info[position].encrypted_size & 0xF,
+                0,
+                svpMeta->u.u3.chunk_info[position].offset + svpMeta->u.u3.chunk_info[position].clear_size + (svpMeta->u.u3.chunk_info[position].encrypted_size & ~0xF)});
+        } else {
+            // this one is already aligned
+            alignedChunks.push_back({
+                svpMeta->u.u3.chunk_info[position].clear_size,
+                svpMeta->u.u3.chunk_info[position].encrypted_size,
+                svpMeta->u.u3.chunk_info[position].offset});
+        }
+    }
+    if (alignedChunks.size() > svpMeta->u.u3.chunks_cnt) {
+        // svpMeta->u.u3.chunk_info needs to be recreated
+        g_free(svpMeta->u.u3.chunk_info);
+        svpMeta->u.u3.chunks_cnt = alignedChunks.size();
+        svpMeta->u.u3.chunk_info = static_cast<svp_chunk_info *>(g_malloc(svpMeta->u.u3.chunks_cnt * sizeof(svp_chunk_info)));
+        for (size_t position = 0; position < alignedChunks.size(); ++position) {
+            svpMeta->u.u3.chunk_info[position].clear_size = std::get<0>(alignedChunks[position]);
+            svpMeta->u.u3.chunk_info[position].encrypted_size = std::get<1>(alignedChunks[position]);
+            svpMeta->u.u3.chunk_info[position].offset = std::get<2>(alignedChunks[position]);
+        }
+    }
+}
+#endif
+
 OpenCDMError opencdm_gstreamer_session_decrypt(struct OpenCDMSession* session, GstBuffer* buffer, GstBuffer* subSample, const uint32_t subSampleCount,
                                                GstBuffer* IV, GstBuffer* keyID, uint32_t initWithLast15)
 {
@@ -195,6 +240,12 @@ OpenCDMError opencdm_gstreamer_session_decrypt(struct OpenCDMSession* session, G
             gst_structure_get_uint(protectionMeta->info, "skip_byte_block", &pattern.clear_blocks);
         }
 
+#ifdef PLAYREADY_CBCS_URSR_19_2_2_ALIGN_16_FIX
+        if (encScheme == AesCbc_Cbcs) {
+            correct_chunks_in_svp_meta_for_cbcs(svpMeta);
+        }
+#endif
+
         //Create a SubSampleInfo Array with mapping
         SubSampleInfo * subSampleInfoPtr = nullptr;
         uint32_t nonEmptySubSampleInfoCount = subSampleCount;
-- 
2.25.1

