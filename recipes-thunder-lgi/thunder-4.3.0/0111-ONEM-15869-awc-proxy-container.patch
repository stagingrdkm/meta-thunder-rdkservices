ONEM-15869 Added AWCProxyContainer impl.
ONEM-22512 Isolated DBusClient impl. to be reusable among (proxy) containers.
ONEM-22510 Refactored (fixed config parsing) when adding OCDM support

Start()/Stop() will reject request if already started or stopped.

Added support for per-plugin timeout config (for AWCProxyContainer)
If plugin json config has:

"root":{
    ...
    "configuration":{
        "awc_container":"proxy",
        "start_timeout": 2000,
        "stop_timeout": 5000
    },
    ...
}


AWCProxyContainer does not use AWC API (which is dedicated only for JSAPP).
It uses API documented in api.xml. DBus client is constructed based on this API.
On SLauncher side same api.xml exist (and needs to be kept in sync),
and is used to create DBus server.

author: wlodzimierz.lipert@consult.red

--- a/Source/extensions/processcontainers/CMakeLists.txt
+++ b/Source/extensions/processcontainers/CMakeLists.txt
@@ -50,7 +50,15 @@ elseif(PROCESSCONTAINERS_CLIB)
 elseif(PROCESSCONTAINERS_DOBBY)
         target_sources(${TARGET} PRIVATE implementations/DobbyImplementation/DobbyImplementation.cpp)
 elseif(PROCESSCONTAINERS_AWC)
-        target_sources(${TARGET} PRIVATE implementations/AWCImplementation/AWCImplementation.cpp)
+        target_sources(
+            ${TARGET} PRIVATE
+            implementations/AWCImplementation/AWC.cpp
+            implementations/AWCImplementation/AWCContainerAdministrator.cpp
+            implementations/AWCImplementation/AWCContainerBase.cpp
+            implementations/AWCImplementation/AWCImplementation.cpp
+            implementations/AWCImplementation/AWCProxyContainer.cpp
+            implementations/AWCImplementation/dbus/Client.cpp
+            implementations/AWCImplementation/dbus/api.c)
 endif()
 
 set(PUBLIC_HEADERS
@@ -141,15 +149,27 @@ elseif (PROCESSCONTAINERS_DOBBY)
 elseif (PROCESSCONTAINERS_AWC)
         find_package(LXC REQUIRED)
         find_package(Slauncher REQUIRED)
+        find_package(LibGio REQUIRED)
+        find_package(LibGioUnix REQUIRED)
+        find_package(LibGlib REQUIRED)
+        find_package(LibGobject REQUIRED)
         target_link_libraries(${TARGET}
                 PRIVATE
                 Slauncher::Slauncher
                 CompileSettingsDebug::CompileSettingsDebug
+                ${LIBGIO_INCLUDE_LIBRARIES}
+                ${LIBGIOUNIX_LIBRARIES}
+                ${LIBGLIB_LIBRARIES}
+                ${LIBGOBJECT_LIBRARIES}
                 )
 
         target_include_directories( ${TARGET}
                 PRIVATE
                 Slauncher::Slauncher
+                ${LIBGIO_INCLUDE_DIRS}
+                ${LIBGIOUNIX_INCLUDE_DIRS}
+                ${LIBGLIB_INCLUDE_DIRS}
+                ${LIBGOBJECT_INCLUDE_DIRS}
                 )
 endif()
 
--- a/Source/extensions/processcontainers/common/BaseRefCount.h
+++ b/Source/extensions/processcontainers/common/BaseRefCount.h
@@ -19,6 +19,10 @@
 
 #pragma once
 
+#include <cstdint>
+
+#include "core/Sync.h"
+
 namespace WPEFramework {
 namespace ProcessContainers {
 
--- /dev/null
+++ b/Source/extensions/processcontainers/implementations/AWCImplementation/AWC.cpp
@@ -0,0 +1,55 @@
+#include "AWC.h"
+
+#include <algorithm>
+
+#include "Tracing.h"
+
+
+using namespace WPEFramework::ProcessContainers;
+
+
+AWCStateChangeNotifier::AWCStateChangeNotifier() : _listeners(), _mutex() {};
+
+void AWCStateChangeNotifier::addListener(AWCStateChangeListener * listener)
+{
+    if (!listener) return;
+    std::lock_guard<std::mutex> lock(_mutex);
+    if (std::find(_listeners.begin(), _listeners.end(), listener) == _listeners.end())
+    {
+        _listeners.push_back(listener);
+    }
+    else
+    {
+        TRACE_L1("%s listener already registrered %p", __FUNCTION__, listener);
+    }
+}
+
+void AWCStateChangeNotifier::removeListener(AWCStateChangeListener * listener)
+{
+    std::lock_guard<std::mutex> lock(_mutex);
+    _listeners.erase(std::remove(_listeners.begin(), _listeners.end(), listener), _listeners.end());
+}
+
+void AWCStateChangeNotifier::notify(int req_id, awc::awc_app_state_t app_state, int status, unsigned int pid)
+{
+    std::lock_guard<std::mutex> lock(_mutex);
+    for (auto listener : _listeners)
+    {
+        listener->notifyStateChange(req_id, app_state, status, pid);
+    }
+}
+
+AWCListener::AWCListener(AWCStateChangeNotifier * notifier)
+    : _notifier(notifier)
+{}
+
+void AWCListener::notifyWindowChange(int window_id, awc::AWCClient::awc_window_state_t window_state, unsigned int pid)
+{
+    // intentionally left empty
+}
+
+void AWCListener::notifyStateChange(int req_id, awc::awc_app_state_t app_state, int status, unsigned int pid)
+{
+    TRACE_L3("%s req_id=%d app_state=%d status=%d pid=%u", _TRACE_FUNCTION_, req_id, app_state, status, pid);
+    _notifier->notify(req_id, app_state, status, pid);
+}
--- /dev/null
+++ b/Source/extensions/processcontainers/implementations/AWCImplementation/AWC.h
@@ -0,0 +1,41 @@
+#pragma once
+
+#define _TRACE_FUNCTION_ __PRETTY_FUNCTION__
+
+#include <mutex>
+
+#include <AWCClient.h>
+
+namespace WPEFramework {
+namespace ProcessContainers {
+
+
+class AWCStateChangeListener {
+public:
+    virtual void notifyStateChange(int req_id, awc::awc_app_state_t app_state, int status, unsigned int pid) = 0;
+};
+
+class AWCStateChangeNotifier {
+public:
+    AWCStateChangeNotifier();
+    void addListener(AWCStateChangeListener * listener);
+    void removeListener(AWCStateChangeListener * listener);
+    void notify(int req_id, awc::awc_app_state_t app_state, int status, unsigned int pid);
+private:
+    std::vector<AWCStateChangeListener *> _listeners;
+    std::mutex _mutex;
+};
+
+class AWCListener : public awc::AWCClient::Listener
+{
+public:
+    AWCListener(AWCStateChangeNotifier * notifier);
+    ~AWCListener() {};
+    void notifyWindowChange(int window_id, awc::AWCClient::awc_window_state_t window_state, unsigned int pid) override;
+    void notifyStateChange(int req_id, awc::awc_app_state_t app_state, int status, unsigned int pid) override;
+private:
+    AWCStateChangeNotifier * _notifier;
+};
+
+} /* ProcessContainers */
+} /* WPEFramework */
--- /dev/null
+++ b/Source/extensions/processcontainers/implementations/AWCImplementation/AWCContainerAdministrator.cpp
@@ -0,0 +1,110 @@
+#include <algorithm>
+
+#include "AWCContainerAdministrator.h"
+#include "AWCImplementation.h"
+#include "AWCProxyContainer.h"
+#include "processcontainers/Tracing.h"
+
+using namespace WPEFramework::ProcessContainers;
+using namespace WPEFramework::Core;
+
+
+PluginConfig::PluginConfig(const std::string &path):
+    JSON::Container()
+{
+    Core::JSON::String useProxyValue;
+    Core::JSON::DecUInt32 startTimeoutValue{10 * 1000};
+    Core::JSON::DecUInt32 stopTimeoutValue{10 * 1000};
+
+    Add(_T("awc_container"), &useProxyValue);
+    Add(_T("start_timeout"), &startTimeoutValue);
+    Add(_T("stop_timeout"), &stopTimeoutValue);
+
+    if(path.empty()) return;
+
+    OptionalType<JSON::Error> error;
+    FromString(path, error);
+
+    if(error.IsSet())
+    {
+        TRACE_L1(
+                "Parsing %s failed with %s",
+                path.c_str(), ErrorDisplayMessage(error.Value()).c_str());
+    }
+
+    using namespace std::chrono;
+
+    if(useProxyValue == _T("proxy")) useProxy = true;
+    startTimeout = milliseconds{startTimeoutValue.Value()};
+    stopTimeout = milliseconds{stopTimeoutValue.Value()};
+
+    Remove(_T("awc_container"));
+    Remove(_T("start_timeout"));
+    Remove(_T("stop_timeout"));
+}
+
+AWCContainerAdministrator::AWCContainerAdministrator()
+    : BaseContainerAdministrator()
+{
+    TRACE_L1("%p", this);
+    awcClient_ = awc::AWCClient::getInstance();
+    if (awcClient_) {
+        awcClientListener_ = std::make_shared<AWCListener>(this);
+        awcClient_->setListener(awcClientListener_);
+    }
+}
+
+AWCContainerAdministrator::~AWCContainerAdministrator()
+{
+    TRACE_L1("%p", this);
+    if (awcClient_ && awcClientListener_) {
+        awcClient_->removeListener(awcClientListener_);
+    }
+}
+
+IContainer* AWCContainerAdministrator::Container(
+    const string& name,
+    IStringIterator& searchpaths,
+    const string& containerLogDir,
+    const string& configuration)
+{
+    std::string config = configuration;
+
+    // logs dont like multi line strings
+    std::replace_if(
+            std::begin(config), std::end(config),
+        [](char c){return '\n' == c;}, ' ');
+
+    TRACE_L1(
+        "(%p) callsign=%s, logDir=%s, config=%s",
+        this, name.c_str(), containerLogDir.c_str(), config.c_str());
+
+    const PluginConfig cfg{configuration};
+
+    IContainer* container = Get(name);
+    const auto append = !container;
+
+    if(!container && cfg.useProxy)
+    {
+        container = new AWCProxyContainer(name, cfg, &dbusClient_);
+    }
+    else if(!container)
+    {
+        container = new AWCContainer(name, awcClient_, this);
+    }
+    if(append)
+    {
+        this->InternalLock();
+        InsertContainer(container);
+        this->InternalUnlock();
+    }
+
+    if(!container) TRACE_L1("not supported container type: %s", name.c_str());
+    return container;
+}
+
+IContainerAdministrator& IContainerAdministrator::Instance()
+{
+    static AWCContainerAdministrator& myAWCContainerAdministrator = Core::SingletonType<AWCContainerAdministrator>::Instance();
+    return myAWCContainerAdministrator;
+}
--- /dev/null
+++ b/Source/extensions/processcontainers/implementations/AWCImplementation/AWCContainerAdministrator.h
@@ -0,0 +1,47 @@
+#pragma once
+
+#include <mutex>
+#include <vector>
+
+
+#include "AWC.h"
+#include "dbus/Client.h"
+#include "processcontainers/common/BaseAdministrator.h"
+#include "core/JSON.h"
+
+namespace WPEFramework {
+namespace ProcessContainers {
+
+struct PluginConfig: public Core::JSON::Container
+{
+    bool useProxy{false};
+    std::chrono::milliseconds startTimeout;
+    std::chrono::milliseconds stopTimeout;
+
+    PluginConfig(const PluginConfig&) = delete;
+    PluginConfig& operator=(const PluginConfig&) = delete;
+    PluginConfig(const std::string &path);
+};
+
+
+class AWCContainerAdministrator:
+    public BaseContainerAdministrator<IContainer>,
+    public AWCStateChangeNotifier
+{
+    friend class AWCContainer;
+    friend class Core::SingletonType<AWCContainerAdministrator>;
+private:
+    awc::AWCClient * awcClient_;
+    std::shared_ptr<AWCListener> awcClientListener_;
+    dbus::Client dbusClient_;
+    AWCContainerAdministrator();
+public:
+    AWCContainerAdministrator(const AWCContainerAdministrator&) = delete;
+    AWCContainerAdministrator& operator=(const AWCContainerAdministrator&) = delete;
+    ~AWCContainerAdministrator() override;
+    IContainer* Container(const string& name, IStringIterator& searchpaths, const string& containerLogDir, const string& configuration) override;
+    void Logging(const string& globalLogDir, const string& loggingOptions) override {};
+};
+
+} /* ProcessContainers */
+} /* WPEFramework */
--- /dev/null
+++ b/Source/extensions/processcontainers/implementations/AWCImplementation/AWCContainerBase.cpp
@@ -0,0 +1,63 @@
+#include "AWCContainerBase.h"
+
+using namespace WPEFramework::ProcessContainers;
+
+struct AWCMemoryInfo : public BaseRefCount<IMemoryInfo> {
+    AWCMemoryInfo()
+    {
+    }
+
+    uint64_t Allocated() const
+    {
+        return 0;
+    }
+
+    uint64_t Resident() const
+    {
+        return 0;
+    }
+
+    uint64_t Shared() const
+    {
+        return 0;
+    }
+};
+
+struct AWCProcessorInfo : public BaseRefCount<IProcessorInfo> {
+    AWCProcessorInfo()
+    {
+    }
+
+    uint64_t TotalUsage() const
+    {
+        return 0;
+    }
+
+    uint64_t CoreUsage(uint32_t coreNum) const
+    {
+        return 0;
+    }
+
+    uint16_t NumberOfCores() const
+    {
+        return 0;
+    }
+};
+
+IMemoryInfo* AWCContainerBase::Memory() const
+{
+    TRACE_L3("%s", _TRACE_FUNCTION_);
+    return new AWCMemoryInfo();
+}
+
+IProcessorInfo* AWCContainerBase::ProcessorInfo() const
+{
+    TRACE_L3("%s", _TRACE_FUNCTION_);
+    return new AWCProcessorInfo();
+}
+
+INetworkInterfaceIterator* AWCContainerBase::NetworkInterfaces() const
+{
+    TRACE_L3("%s", _TRACE_FUNCTION_);
+    return nullptr;
+}
--- /dev/null
+++ b/Source/extensions/processcontainers/implementations/AWCImplementation/AWCContainerBase.h
@@ -0,0 +1,26 @@
+#pragma once
+
+#define _TRACE_FUNCTION_ __PRETTY_FUNCTION__
+
+#include "common/BaseRefCount.h"
+#include "processcontainers/ProcessContainer.h"
+
+namespace WPEFramework {
+namespace ProcessContainers {
+
+class AWCContainerBase:
+    public BaseRefCount<IContainer>
+{
+private:
+    string id_;
+public:
+    AWCContainerBase(std::string id): id_{std::move(id)} {}
+
+    const string& Id() const override {return id_;}
+    IMemoryInfo* Memory() const override;
+    IProcessorInfo* ProcessorInfo() const override;
+    INetworkInterfaceIterator* NetworkInterfaces() const override;
+};
+
+} /* ProcessContainers */
+} /* WPEFramework */
--- a/Source/extensions/processcontainers/implementations/AWCImplementation/AWCImplementation.cpp
+++ b/Source/extensions/processcontainers/implementations/AWCImplementation/AWCImplementation.cpp
@@ -17,321 +17,153 @@
  * limitations under the License.
  */
 
+#include "AWCContainerAdministrator.h"
 #include "AWCImplementation.h"
-#include "processcontainers/common/CGroupContainerInfo.h"
+#include "processcontainers/Tracing.h"
 
-#define _TRACE_FUNCTION_ __PRETTY_FUNCTION__
 
-namespace WPEFramework {
-namespace ProcessContainers {
+using namespace WPEFramework::ProcessContainers;
 
-    // stubs only implementation
-    struct AWCMemoryInfo : public BaseRefCount<IMemoryInfo> {
-        AWCMemoryInfo()
-        {
-        }
-
-        uint64_t Allocated() const
-        {
-            return 0;
-        }
-
-        uint64_t Resident() const
-        {
-            return 0;
-        }
-
-        uint64_t Shared() const
-        {
-            return 0;
-        }
-    };
-
-    // stubs only implementation
-    struct AWCProcessorInfo : public BaseRefCount<IProcessorInfo> {
-        AWCProcessorInfo()
-        {
-        }
-
-        uint64_t TotalUsage() const
-        {
-            return 0;
-        }
-
-        uint64_t CoreUsage(uint32_t coreNum) const
-        {
-            return 0;
-        }
-
-        uint16_t NumberOfCores() const
-        {
-            return 0;
-        }
-    };
-
-    AWCContainer::AWCContainer(const string& name, awc::AWCClient * client, AWCStateChangeNotifier * notifier, const string& containerLogDir, const string& configuration)
-        : _name(name)
-        , _pid(0)
-        , _runId(-1)
-        , _appState(awc::AWC_STATE_UNKNOWN)
-        , _referenceCount(1)
-        , _client(client)
-        , _notifier(notifier)
-        , _mutex()
-        , _cv()
-        , _waitForResponse(false)
-    {
-        TRACE_L3("%s name=%s client=%p conntainerLogDir=%s configuration=%s", _TRACE_FUNCTION_, _name.c_str(), _client, containerLogDir.c_str(), configuration.c_str());
-        _notifier->addListener(this);
-    }
 
-    AWCContainer::~AWCContainer()
-    {
-        TRACE_L3("%s _name=%s _pid=%d _client=%p", _TRACE_FUNCTION_, _name.c_str(), _pid, _client);
-        if (IsRunning()) {
-            Stop(2000);
-        }
-        _notifier->removeListener(this);
-        TRACE(ProcessContainers::ProcessContainerization, (_T("Container [%s] released"), _name.c_str()));
+AWCContainer::AWCContainer(const string& id, awc::AWCClient * client, AWCStateChangeNotifier * notifier):
+    AWCContainerBase(id)
+    , _client(client)
+    , _notifier(notifier)
+{
+    TRACE_L1("name=%s client=%p", Id().c_str(), _client);
+    _notifier->addListener(this);
+}
 
-        static_cast<AWCContainerAdministrator&>(AWCContainerAdministrator::Instance()).RemoveContainer(this);
+AWCContainer::~AWCContainer()
+{
+    TRACE_L1("id=%s _pid=%d _client=%p", Id().c_str(), _pid, _client);
+    if (IsRunning()) {
+        Stop(2000);
     }
+    _notifier->removeListener(this);
+    TRACE(ProcessContainerization, (_T("Container [%s] released"), Id().c_str()));
 
-    const string& AWCContainer::Id() const
-    {
-        TRACE_L3("%s id=%s", _TRACE_FUNCTION_, _name.c_str());
-        return _name;
-    }
+    static_cast<AWCContainerAdministrator &>(AWCContainerAdministrator::Instance()).RemoveContainer(this);
+}
 
-    uint32_t AWCContainer::Pid() const
-    {
-        TRACE_L3("%s _name=%s _pid=%d _appState=%d", _TRACE_FUNCTION_, _name.c_str(), _pid, _appState);
-        std::lock_guard<std::mutex> lock(_mutex);
-        return _appState == awc::AWC_STATE_STARTED ? _pid : 0;
-    }
+uint32_t AWCContainer::Pid() const
+{
+    TRACE_L1("id=%s _pid=%d _appState=%d", Id().c_str(), _pid, _appState);
+    std::lock_guard<std::mutex> lock(_mutex);
+    return _appState == awc::AWC_STATE_STARTED ? _pid : 0;
+}
 
-    IMemoryInfo* AWCContainer::Memory() const
-    {
-        TRACE_L3("%s", _TRACE_FUNCTION_);
-        return new AWCMemoryInfo();
-    }
+bool AWCContainer::IsRunning() const
+{
+    TRACE_L1("id=%s", Id().c_str());
+    std::lock_guard<std::mutex> lock(_mutex);
+    bool isRunning = _runId > 0 && _pid > 0 && _appState == awc::AWC_STATE_STARTED;
+    TRACE_L1("isRunning=%d", isRunning);
+    return isRunning;
+}
 
-    IProcessorInfo* AWCContainer::ProcessorInfo() const
+bool AWCContainer::Start(const string& command, IStringIterator& parameters)
+{
+    if(IsRunning())
     {
-        TRACE_L3("%s", _TRACE_FUNCTION_);
-        return new AWCProcessorInfo();
+        TRACE_L1("id=%s(%p) already running", Id().c_str(), this);
+        return false;
     }
 
-    INetworkInterfaceIterator* AWCContainer::NetworkInterfaces() const
-    {
-        TRACE_L3("%s", _TRACE_FUNCTION_);
-        return nullptr;
-    }
+    awc::AWCClient::str_vect_sptr_t windowParams = std::make_shared<std::vector<std::string>>();
+    awc::AWCClient::str_vect_sptr_t appParams = std::make_shared<std::vector<std::string>>();
 
-    bool AWCContainer::IsRunning() const
+    std::string cmd;
+    // real - from framework command line paramaters
+    while(parameters.Next())
     {
-        TRACE_L3("%s _name=%s", _TRACE_FUNCTION_, _name.c_str());
-        std::lock_guard<std::mutex> lock(_mutex);
-        bool isRunning = _runId > 0 && _pid > 0 && _appState == awc::AWC_STATE_STARTED;
-        TRACE_L1("%s isRunning=%d", _TRACE_FUNCTION_, isRunning);
-        return isRunning;
+        if(!cmd.empty()) cmd += ' ';
+        cmd += parameters.Current();
+        appParams->push_back(parameters.Current());
     }
 
-    bool AWCContainer::Start(const string& command, IStringIterator& parameters)
-    {
-        TRACE_L1("%s _name=%s command=%s numOfParams=%d", _TRACE_FUNCTION_, _name.c_str(), command.c_str(), parameters.Count());
-        int paramIdx = 0;
-        awc::AWCClient::str_vect_sptr_t windowParams = std::make_shared<std::vector<std::string>>();
-        awc::AWCClient::str_vect_sptr_t appParams = std::make_shared<std::vector<std::string>>();
-
-        // real - from framework command line paramaters
-        while(parameters.Next())
-        {
-            TRACE_L3("%s param[%d]=%s", _TRACE_FUNCTION_, paramIdx++, parameters.Current().c_str());
-            appParams->push_back(parameters.Current());
-        }
-
-        int run_id = -1;
-        bool result = false;
-        {
-            std::unique_lock<std::mutex> lock(_mutex);
-            _pid = 0;
-            _runId = -1;
-            _appState = awc::AWC_STATE_UNKNOWN;
-            TRACE_L1("%s starting app_name=%s", _TRACE_FUNCTION_, _name.c_str());
-            awc::AWCClient::awc_status_t awc_result = _client->start(_name,
-                                                                    appParams,
-                                                                    windowParams, run_id);
-            TRACE_L1("%s starting result result=%d run_id=%d", _TRACE_FUNCTION_, awc_result, run_id);
-            result = (awc_result == awc::AWCClient::AWC_STATUS_OK);
-            while (result && _pid == 0 && _appState != awc::AWC_STATE_STARTED)
-            {
-                _runId = run_id; _waitForResponse = true;
-                TRACE_L1("%s waiting for start _name=%s", _TRACE_FUNCTION_, _name.c_str());
-                _cv.wait_for(lock, std::chrono::seconds(30), [this] { return !_waitForResponse; });
-                _waitForResponse = false;
-                if (_appState != awc::AWC_STATE_STARTED && _appState != awc::AWC_STATE_STARTING)
-                {
-                    TRACE_L1("%s unexpected notification arrived _pid=%d _appState=%d", _TRACE_FUNCTION_, _pid, _appState);
-                    result = false;
-                }
-            }
-        }
-        TRACE_L1("%s _pid=%d _runId=%d result=%d", _TRACE_FUNCTION_, _pid, _runId, result);
-        return result;
-    }
+    TRACE_L1(
+        "id=%s command=%s numOfParams=%d params=%s",
+        Id().c_str(), command.c_str(), parameters.Count(), cmd.c_str());
 
-    bool AWCContainer::Stop(const uint32_t timeout /*ms*/)
+    int run_id = -1;
+    bool result = false;
     {
-        TRACE_L1("%s _name=%s timeout=%u _pid=%u _runId=%d", _TRACE_FUNCTION_, _name.c_str(), timeout, _pid, _runId);
         std::unique_lock<std::mutex> lock(_mutex);
-        awc::AWCClient::awc_status_t awc_result = _client->stop(_pid, 0); // documentation: exit type is important only for Netflix
-        bool result = (awc_result == awc::AWCClient::AWC_STATUS_OK);
-        TRACE_L1("%s awc_result=%d result=%d", _TRACE_FUNCTION_, awc_result, result);
-        if (result)
-        {
-            _waitForResponse = true;
-            TRACE_L1("%s waiting for stop _name=%s timeout=%u[ms]", _TRACE_FUNCTION_, _name.c_str(), timeout);
+        _pid = 0;
+        _runId = -1;
+        _appState = awc::AWC_STATE_UNKNOWN;
+        TRACE_L1("starting appid=%s", Id().c_str());
+        awc::AWCClient::awc_status_t awc_result = _client->start(Id(),
+                                                                appParams,
+                                                                windowParams, run_id);
+        TRACE_L1("starting result result=%d run_id=%d", awc_result, run_id);
+        result = (awc_result == awc::AWCClient::AWC_STATUS_OK);
+        while (result && _pid == 0 && _appState != awc::AWC_STATE_STARTED)
+        {
+            _runId = run_id; _waitForResponse = true;
+            TRACE_L1("waiting for start Id()=%s", Id().c_str());
             _cv.wait_for(lock, std::chrono::seconds(30), [this] { return !_waitForResponse; });
             _waitForResponse = false;
-            if (_appState != awc::AWC_STATE_STOPPED)
+            if (_appState != awc::AWC_STATE_STARTED && _appState != awc::AWC_STATE_STARTING)
             {
-                TRACE_L1("%s stop notification not arrived _pid=%d _appState=%d", _TRACE_FUNCTION_, _pid, _appState);
+                TRACE_L1("unexpected notification arrived _pid=%d _appState=%d", _pid, _appState);
                 result = false;
             }
         }
-        TRACE_L1("%s result=%d", _TRACE_FUNCTION_, result);
-        return result;
-    }
-
-    void AWCContainer::AddRef() const
-    {
-        TRACE_L3("%s _name=%s", _TRACE_FUNCTION_, _name.c_str());
-        WPEFramework::Core::InterlockedIncrement(_referenceCount);
-    }
-
-    uint32_t AWCContainer::Release() const
-    {
-        TRACE_L3("%s _name=%s", _TRACE_FUNCTION_, _name.c_str());
-        uint32_t retval = WPEFramework::Core::ERROR_NONE;
-        if (WPEFramework::Core::InterlockedDecrement(_referenceCount) == 0) {
-            delete this;
-            retval = WPEFramework::Core::ERROR_DESTRUCTION_SUCCEEDED;
-        }
-        return retval;
-    }
-
-    void AWCContainer::notifyStateChange(int req_id, awc::awc_app_state_t app_state, int status, unsigned int pid)
-    {
-        std::lock_guard<std::mutex> lock(_mutex);
-        if (_runId >= 0 && req_id == _runId)
-        {
-            TRACE_L1("%s _name=%s _runId=%d req_id=%d app_state=%d status=%d pid=%d", _TRACE_FUNCTION_, _name.c_str(), _runId, req_id, app_state, status, pid);
-            if (_appState != awc::AWC_STATE_STOPPED)
-            {
-                _pid = pid;
-                _appState = app_state;
-            }
-            else
-            {
-                TRACE_L1("%s container was alredy stopped", _TRACE_FUNCTION_);
-            }
-            if (_waitForResponse)
-            {
-                _waitForResponse = false;
-                _cv.notify_one();
-            }
-        }
     }
+    TRACE_L1("_pid=%d _runId=%d result=%d", _pid, _runId, result);
+    return result;
+}
 
-    AWCContainerAdministrator::AWCContainerAdministrator()
-        : BaseContainerAdministrator()
+bool AWCContainer::Stop(const uint32_t timeout /*ms*/)
+{
+    if(!IsRunning())
     {
-        TRACE(ProcessContainers::ProcessContainerization, (_T("AWC library initialization")));
-        TRACE_L3("%s Getting AWC client instance", _TRACE_FUNCTION_);
-        _client = awc::AWCClient::getInstance();
-        TRACE_L3("%s AWC client instance %p", _TRACE_FUNCTION_, _client);
-        if (_client)
-        {
-            _client->setListener(std::make_shared<AWCListener>(this));
-        }
+        TRACE_L1("id=%s(%p) not running", Id().c_str(), this);
+        return true;
     }
 
-    AWCContainerAdministrator::~AWCContainerAdministrator()
+    TRACE_L1("id=%s timeout=%u _pid=%u _runId=%d", Id().c_str(), timeout, _pid, _runId);
+    std::unique_lock<std::mutex> lock(_mutex);
+    awc::AWCClient::awc_status_t awc_result = _client->stop(_pid, 0); // documentation: exit type is important only for Netflix
+    bool result = (awc_result == awc::AWCClient::AWC_STATUS_OK);
+    TRACE_L1("awc_result=%d result=%d", awc_result, result);
+    while (result && _appState != awc::AWC_STATE_STOPPED)
     {
-        TRACE_L3("%s", _TRACE_FUNCTION_);
-        if (_client)
+        _waitForResponse = true;
+        TRACE_L1("waiting for stop id=%s timeout=%u[ms]", Id().c_str(), timeout);
+        const auto status = _cv.wait_for(lock, std::chrono::seconds(30), [this] { return !_waitForResponse; });
+        if (_waitForResponse && !status && _appState != awc::AWC_STATE_STOPPED)
         {
-            _client->removeListener();
+            TRACE_L1("timeout, stop notification not arrived _pid=%d _appState=%d", _pid, _appState);
+            result = false;
         }
+        _waitForResponse = false;
     }
+    TRACE_L1("result=%d", result);
+    return result;
+}
 
-    IContainer* AWCContainerAdministrator::Container(const string& name, IStringIterator& searchpaths, const string& containerLogDir, const string& configuration)
-    {
-        TRACE_L3("%s", _TRACE_FUNCTION_);
-        AWCContainer* container = nullptr;
-        container = new AWCContainer(name, _client, this, containerLogDir, configuration);
-        if (container == nullptr) {
-            TRACE(ProcessContainers::ProcessContainerization, (_T("Container Definition for name [%s] could not be found!"), name.c_str()));
-        }
-
-        return static_cast<IContainer*>(container);
-    }
-
-    void AWCContainerAdministrator::Logging(const string& globalLogDir, const string& loggingOptions)
-    {
-        TRACE_L3("%s", _TRACE_FUNCTION_);
-    }
-
-    IContainerAdministrator& IContainerAdministrator::Instance()
-    {
-        TRACE_L3("%s", _TRACE_FUNCTION_);
-        static AWCContainerAdministrator& myAWCContainerAdministrator = Core::SingletonType<AWCContainerAdministrator>::Instance();
-        return myAWCContainerAdministrator;
-    }
-
-    AWCContainerAdministrator::AWCListener::AWCListener(AWCStateChangeNotifier * notifier) : _notifier(notifier) {}
-
-    void AWCContainerAdministrator::AWCListener::notifyWindowChange(int window_id, awc::AWCClient::awc_window_state_t window_state, unsigned int pid)
-    {
-        // intentionally left empty
-    }
-
-    void AWCContainerAdministrator::AWCListener::notifyStateChange(int req_id, awc::awc_app_state_t app_state, int status, unsigned int pid)
-    {
-        TRACE_L3("%s req_id=%d app_state=%d status=%d pid=%u", _TRACE_FUNCTION_, req_id, app_state, status, pid);
-        _notifier->notify(req_id, app_state, status, pid);
-    }
-
-    AWCStateChangeNotifier::AWCStateChangeNotifier() : _listeners(), _mutex() {};
-
-    void AWCStateChangeNotifier::addListener(AWCStateChangeListener * listener)
+void AWCContainer::notifyStateChange(int req_id, awc::awc_app_state_t app_state, int status, unsigned int pid)
+{
+    std::lock_guard<std::mutex> lock(_mutex);
+    if (_runId >= 0 && req_id == _runId)
     {
-        if (!listener) return;
-        std::lock_guard<std::mutex> lock(_mutex);
-        if (std::find(_listeners.begin(), _listeners.end(), listener) == _listeners.end())
+        TRACE_L1("id=%s _runId=%d req_id=%d app_state=%d status=%d pid=%d", Id().c_str(), _runId, req_id, app_state, status, pid);
+        if (_appState != awc::AWC_STATE_STOPPED)
         {
-            _listeners.push_back(listener);
+            _pid = pid;
+            _appState = app_state;
         }
         else
         {
-            TRACE_L1("%s listener already registrered %p", _TRACE_FUNCTION_, listener);
+            TRACE_L1("container was alredy stopped");
         }
-    }
-
-    void AWCStateChangeNotifier::removeListener(AWCStateChangeListener * listener)
-    {
-        std::lock_guard<std::mutex> lock(_mutex);
-        _listeners.erase(std::remove(_listeners.begin(), _listeners.end(), listener), _listeners.end());
-    }
-
-    void AWCStateChangeNotifier::notify(int req_id, awc::awc_app_state_t app_state, int status, unsigned int pid)
-    {
-        std::lock_guard<std::mutex> lock(_mutex);
-        for (auto listener : _listeners)
+        if (_waitForResponse)
         {
-            listener->notifyStateChange(req_id, app_state, status, pid);
+            _waitForResponse = false;
+            _cv.notify_one();
         }
     }
 }
-} //namespace WPEFramework
diff --git a/Source/processcontainers/implementations/AWCImplementation/AWCImplementation.h b/Source/processcontainers/implementations/AWCImplementation/AWCImplementation.h
index 961ec25..88a1a8b 100644
--- a/Source/extensions/processcontainers/implementations/AWCImplementation/AWCImplementation.h
+++ b/Source/extensions/processcontainers/implementations/AWCImplementation/AWCImplementation.h
@@ -19,104 +19,43 @@
 
 #pragma once
 
-#include "processcontainers/ProcessContainer.h"
-#include "processcontainers/common/BaseAdministrator.h"
-#include "processcontainers/common/BaseRefCount.h"
-#include "Module.h"
-#include "Tracing.h"
-#include <cctype>
-#include <vector>
-#include <mutex>
 #include <condition_variable>
-#include <AWCClient.h>
+#include <mutex>
+
+#include "AWC.h"
+#include "AWCContainerBase.h"
 
 namespace WPEFramework {
 namespace ProcessContainers {
 
-    class AWCStateChangeListener {
-    public:
-        virtual void notifyStateChange(int req_id, awc::awc_app_state_t app_state, int status, unsigned int pid) = 0;
-    };
-
-    class AWCStateChangeNotifier {
-    public:
-        AWCStateChangeNotifier();
-        void addListener(AWCStateChangeListener * listener);
-        void removeListener(AWCStateChangeListener * listener);
-        void notify(int req_id, awc::awc_app_state_t app_state, int status, unsigned int pid);
-
-    private:
-        std::vector<AWCStateChangeListener *> _listeners;
-        std::mutex _mutex;
-    };
-
-    class AWCContainer : public BaseRefCount<IContainer>, AWCStateChangeListener {
-
-    private:
-        friend class AWCContainerAdministrator;
-
-        AWCContainer(const string& name, awc::AWCClient * client, AWCStateChangeNotifier * notifier, const string& containerLogDir, const string& configuration);
-
-    public:
-        AWCContainer(const AWCContainer&) = delete;
-        ~AWCContainer() override;
-
-        AWCContainer& operator=(const AWCContainer&) = delete;
-
-        const string& Id() const override;
-        uint32_t Pid() const override;
-        IMemoryInfo* Memory() const override;
-        IProcessorInfo* ProcessorInfo() const override;
-        INetworkInterfaceIterator* NetworkInterfaces() const override;
-        bool IsRunning() const override;
-
-        bool Start(const string& command, ProcessContainers::IStringIterator& parameters) override;
-        bool Stop(const uint32_t timeout /*ms*/) override;
-
-        void AddRef() const override;
-        uint32_t Release() const override;
-        void notifyStateChange(int req_id, awc::awc_app_state_t app_state, int status, unsigned int pid) override;
-
-    private:
-        const string _name;
-        uint32_t _pid;
-        int _runId;
-        awc::awc_app_state_t _appState;
-        mutable uint32_t _referenceCount;
-        awc::AWCClient * _client;
-        AWCStateChangeNotifier * _notifier;
-        mutable std::mutex _mutex;
-        std::condition_variable _cv;
-        bool _waitForResponse;
-        static std::string const _envVariables[];
-    };
-
-    class AWCContainerAdministrator : public BaseContainerAdministrator<AWCContainer>, public AWCStateChangeNotifier {
-        friend class AWCContainer;
-        friend class Core::SingletonType<AWCContainerAdministrator>;
-
-    private:
-        awc::AWCClient * _client;
-    private:
-        AWCContainerAdministrator();
-
-    public:
-        AWCContainerAdministrator(const AWCContainerAdministrator&) = delete;
-        AWCContainerAdministrator& operator=(const AWCContainerAdministrator&) = delete;
-        ~AWCContainerAdministrator() override;
-        ProcessContainers::IContainer* Container(const string& name, IStringIterator& searchpaths, const string& containerLogDir, const string& configuration) override;
-        void Logging(const string& globalLogDir, const string& loggingOptions) override;
-
-        class AWCListener : public awc::AWCClient::Listener
-        {
-        public:
-            AWCListener(AWCStateChangeNotifier * notifier);
-            ~AWCListener() {};
-            void notifyWindowChange(int window_id, awc::AWCClient::awc_window_state_t window_state, unsigned int pid);
-            void notifyStateChange(int req_id, awc::awc_app_state_t app_state, int status, unsigned int pid);
-        private:
-            AWCStateChangeNotifier * _notifier;
-        };
-    };
-}
-}
+class AWCContainer:
+    public AWCContainerBase,
+    public AWCStateChangeListener
+{
+private:
+    friend class AWCContainerAdministrator;
+
+    AWCContainer(const string& id, awc::AWCClient * client, AWCStateChangeNotifier * notifier);
+public:
+    AWCContainer(const AWCContainer&) = delete;
+    ~AWCContainer() override;
+    AWCContainer& operator=(const AWCContainer&) = delete;
+
+    uint32_t Pid() const override;
+    bool IsRunning() const override;
+    bool Start(const string& command, ProcessContainers::IStringIterator& parameters) override;
+    bool Stop(const uint32_t timeout /*ms*/) override;
+    void notifyStateChange(int req_id, awc::awc_app_state_t app_state, int status, unsigned int pid) override;
+private:
+    uint32_t _pid{0};
+    int _runId{-1};
+    awc::awc_app_state_t _appState{awc::AWC_STATE_UNKNOWN};
+    awc::AWCClient * _client;
+    AWCStateChangeNotifier * _notifier;
+    mutable std::mutex _mutex;
+    std::condition_variable _cv;
+    bool _waitForResponse{false};
+};
+
+} /* ProcessContainers */
+} /* WPEFramework */
--- /dev/null
+++ b/Source/extensions/processcontainers/implementations/AWCImplementation/AWCProxyContainer.cpp
@@ -0,0 +1,185 @@
+#include "AWCContainerAdministrator.h"
+#include "AWCProxyContainer.h"
+
+#define CHECK(cond) ASSERT((cond))
+
+using namespace WPEFramework::ProcessContainers;
+
+AWCProxyContainer::DBusInterface::DBusInterface(
+    AWCProxyContainer *container):
+    dbus::Client::Interface{container ? container->Id() : ""},
+    container_{container}
+{
+    TRACE_L1("id=%s(%p) ", id().c_str(), this);
+    CHECK(!id().empty());
+    CHECK(container_);
+}
+
+AWCProxyContainer::DBusInterface::~DBusInterface()
+{
+    TRACE_L1("id=%s(%p) ", id().c_str(), this);
+    container_ = nullptr;
+}
+
+void AWCProxyContainer::DBusInterface::onStateChange(int pid, AppState appState)
+{
+    TRACE_L1("id=%s(%p) ", id().c_str(), this);
+    CHECK(container_);
+
+    std::lock_guard<std::mutex> lock(container_->mutex_);
+    container_->pid_ = pid;
+    container_->appState_ = appState;
+    container_->cond_.notify_one();
+}
+
+bool AWCProxyContainer::waitForStateChange(
+    Lock &lock, AppState state, milliseconds timeout)
+{
+    TRACE_L1(
+        "begin, curr: %s, desired: %s (timeout %d)",
+        toStr(appState_), toStr(state),
+        int(timeout.count()));
+
+    using namespace std::chrono;
+
+    const auto timestamp = Clock::now();
+
+    auto r = appState_ == state;
+
+    if(!r)
+    {
+        r = cond_.wait_for(lock, timeout, [=](){return appState_ == state;});
+
+        if(!r) TRACE_L1("timeout");
+    }
+
+    const auto diff = duration_cast<milliseconds>(Clock::now() - timestamp);
+
+    TRACE_L1("end, elapsed=%dms result=%d", int(diff.count()), r);
+    return r;
+}
+
+AWCProxyContainer::AWCProxyContainer(
+    const string& name, const PluginConfig &cfg, dbus::Client *client):
+        AWCContainerBase(name),
+        startTimeout_{cfg.startTimeout},
+        stopTimeout_{cfg.stopTimeout},
+        client_{client}
+{
+    TRACE_L1("id=%s(%p) ", Id().c_str(), this);
+    CHECK(client_);
+
+    dbusInterface_ = std::make_shared<DBusInterface>(this);
+    client_->bind(dbusInterface_);
+}
+
+AWCProxyContainer::~AWCProxyContainer()
+{
+    TRACE_L1("id=%s(%p)", Id().c_str(), this);
+
+    if(IsRunning()) Stop(2000);
+    CHECK(client_);
+    client_->unbind(dbusInterface_);
+    static_cast<AWCContainerAdministrator&>(
+        AWCContainerAdministrator::Instance()).RemoveContainer(this);
+}
+
+uint32_t AWCProxyContainer::Pid() const
+{
+    TRACE_L1(
+        "id=%s(%p) pid=%d appState=%s",
+        Id().c_str(), this, pid_, toStr(appState_));
+    std::lock_guard<std::mutex> lock(mutex_);
+    return pid_;
+}
+
+bool AWCProxyContainer::IsRunning() const
+{
+    bool isRunning = false;
+
+    {
+        std::lock_guard<std::mutex> lock(mutex_);
+
+        isRunning = AppState::STARTED == appState_;
+    }
+
+    TRACE_L1("id=%s(%p) isRunning=%d", Id().c_str(), this, isRunning);
+    return isRunning;
+}
+
+bool AWCProxyContainer::Start(const string &command, IStringIterator &params)
+{
+    if(IsRunning())
+    {
+        TRACE_L1("id=%s(%p) already running", Id().c_str(), this);
+        return false;
+    }
+
+    std::string cmd;
+
+    while(params.Next())
+    {
+        if(!cmd.empty()) cmd += ' ';
+        cmd += params.Current();
+    }
+
+    TRACE_L1(
+        "id=%s(%p) command=%s params_num=%d params=%s",
+        Id().c_str(), this, command.c_str(), params.Count(), cmd.c_str());
+
+
+    CHECK(dbusInterface_);
+    if(!dbusInterface_) return false;
+
+    using namespace std::chrono;
+
+    const auto now = Clock::now();
+
+    if(!dbusInterface_->startContainer(client_, command, cmd, startTimeout_))
+    {
+        TRACE_L1("failed to start id=%s(%p)", Id().c_str(), this);
+        return false;
+    }
+
+    const auto diff = duration_cast<milliseconds>(Clock::now() - now);
+
+    if(diff >= startTimeout_) return false;
+
+    std::unique_lock<std::mutex> lock(mutex_);
+    return waitForStateChange(lock, AppState::STARTED, startTimeout_ - diff);
+}
+
+/* provided timeout is not used. Thunder provides 0ms timeout by default
+ * and if this function returns false next Stop() will be retried after 10s */
+bool AWCProxyContainer::Stop(const uint32_t timeout /*ms*/)
+{
+    if(!IsRunning())
+    {
+        TRACE_L1("id=%s(%p) not running", Id().c_str(), this);
+        return true;
+    }
+
+    TRACE_L1(
+        "id=%s(%p) timeout=%u pid=%u",
+        Id().c_str(), this, timeout, pid_);
+
+    CHECK(dbusInterface_);
+    if(!dbusInterface_) return false;
+
+    using namespace std::chrono;
+
+    const auto now = Clock::now();
+
+    if(!dbusInterface_->stopContainer(client_, stopTimeout_))
+    {
+        TRACE_L1("failed to stop id=%s(%p)", Id().c_str(), this);
+        return false;
+    }
+
+    const auto diff = duration_cast<milliseconds>(Clock::now() - now);
+
+    if(diff >= stopTimeout_) return false;
+
+    std::unique_lock<std::mutex> lock(mutex_);
+    return waitForStateChange(lock, AppState::STOPPED, stopTimeout_ - diff);
+}
--- /dev/null
+++ b/Source/extensions/processcontainers/implementations/AWCImplementation/AWCProxyContainer.h
@@ -0,0 +1,58 @@
+#pragma once
+
+#include <condition_variable>
+#include <mutex>
+#include <thread>
+
+#include "AWCContainerBase.h"
+
+namespace WPEFramework {
+namespace ProcessContainers {
+
+class AWCProxyContainer: public AWCContainerBase
+{
+    using AppState = dbus::AppState;
+    using Clock = std::chrono::steady_clock;
+    using Lock = std::unique_lock<std::mutex>;
+    using milliseconds = std::chrono::milliseconds;
+
+    class DBusInterface: public dbus::Client::Interface
+    {
+        AWCProxyContainer *container_;
+
+        void onStateChange(int, AppState) override final;
+    public:
+        DBusInterface(AWCProxyContainer *);
+        ~DBusInterface() override final;
+    };
+
+    using SharedDBusInterface = std::shared_ptr<DBusInterface>;
+
+    friend class AWCContainerAdministrator;
+
+    AWCProxyContainer(const string &name, const PluginConfig &, dbus::Client *);
+
+    bool waitForStateChange(Lock &, AppState, milliseconds);
+public:
+    AWCProxyContainer(const AWCProxyContainer&) = delete;
+    ~AWCProxyContainer() override final;
+    AWCProxyContainer& operator=(const AWCProxyContainer&) = delete;
+
+    uint32_t Pid() const override final;
+    bool IsRunning() const override final;
+    bool Start(const string &, ProcessContainers::IStringIterator &) override final;
+    bool Stop(const uint32_t timeout /*ms*/) override final;
+protected:
+    uint32_t pid_{0};
+    AppState appState_{AppState::UNKNOWN};
+    mutable std::mutex mutex_;
+    std::condition_variable cond_;
+    SharedDBusInterface dbusInterface_;
+    // those values can be overwritten by config
+    const milliseconds startTimeout_;
+    const milliseconds stopTimeout_;
+    dbus::Client *const client_;
+};
+
+} /* ProcessContainers */
+} /* WPEFramework */
--- /dev/null
+++ b/Source/extensions/processcontainers/implementations/AWCImplementation/dbus/Client.cpp
@@ -0,0 +1,488 @@
+#include <functional>
+#include "Client.h"
+#include "core/Trace.h"
+
+#define CHECK(cond) ASSERT((cond))
+
+namespace WPEFramework {
+namespace ProcessContainers {
+namespace dbus {
+
+struct DBusCallbacks
+{
+    static
+    void handleStateChange(ContainerCtrl *, const char *, int, int, gpointer);
+    static
+    void asyncReady(GObject *, GAsyncResult *, gpointer);
+
+    static_assert(
+        std::is_same<
+            decltype(&asyncReady),
+            GAsyncReadyCallback>::value, "signature check failed");
+};
+
+} /* dbus */
+} /* ProcessContainers */
+} /* WPEFramework */
+
+using namespace WPEFramework::ProcessContainers::dbus;
+
+namespace {
+
+const char *noNull(const char *p) {return p ? p : "";}
+const char *dbusInterface() {return "com.lgi.rdk.utils.container.ctrl";}
+const char *dbusPath() {return "/com/lgi/rdk/utils/container/ctrl";}
+
+std::unique_ptr<GCancellable, decltype(&g_object_unref)> makeCancellable()
+{
+    return
+     std::unique_ptr<GCancellable, decltype(&g_object_unref)>
+     {
+         g_cancellable_new(), g_object_unref
+     };
+}
+
+struct GErrorGuard
+{
+    GError *error{nullptr};
+    ~GErrorGuard()
+    {
+        if(error) g_error_free(error);
+        error = nullptr;
+    }
+    const char *msg() const {return error ? noNull(error->message) : "";}
+    int code() const {return error ? error->code : 0;}
+};
+
+struct AsyncReadyCbData
+{
+    using ReadyCb = std::function<bool(GAsyncResult *, GError **)>;
+    /* readyCb will be executed with mutex locked */
+    ReadyCb readyCb;
+    std::mutex *mutex;
+    std::condition_variable *cond;
+    AsyncResult result{AsyncResult::Pending};
+
+    AsyncReadyCbData(ReadyCb cb, std::mutex &m, std::condition_variable &c):
+        readyCb{std::move(cb)},
+        mutex{&m},
+        cond{&c}
+    {}
+};
+
+} /* namespace */
+
+void DBusCallbacks::handleStateChange(
+    ContainerCtrl *instance,
+    const char *id, int pid, int state,
+    gpointer user_data)
+{
+    TRACE_L1("id=%s, pid=%d, state=%d", noNull(id), pid, state);
+    auto client = static_cast<Client *>(user_data);
+
+    CHECK(client);
+    if(!client) return;
+    auto interface = client->findInterface({noNull(id)});
+    if(interface) interface->stateChange(pid, AppState(state));
+}
+
+void DBusCallbacks::asyncReady(GObject *, GAsyncResult *result, gpointer payload)
+{
+    TRACE_L1("begin");
+    auto cbData = reinterpret_cast<AsyncReadyCbData *>(payload);
+    GErrorGuard errorGuard;
+
+    CHECK(cbData);
+    CHECK(cbData->readyCb);
+    CHECK(cbData->mutex);
+    CHECK(cbData->cond);
+
+    if(!cbData || !cbData->readyCb || !cbData->mutex || !cbData->cond) return;
+
+    std::unique_lock<std::mutex> lock{*cbData->mutex};
+    const auto status = cbData->readyCb(result, &errorGuard.error);
+
+    if(!status && errorGuard.error)
+    {
+        TRACE_L1("failed: %s (%d)", errorGuard.msg(), errorGuard.code());
+        cbData->result =
+            G_IO_ERROR_CANCELLED == errorGuard.code()
+            ? AsyncResult::Timeout
+            : AsyncResult::NOK;
+    }
+    else if(!status) cbData->result = AsyncResult::NOK;
+    else cbData->result = AsyncResult::OK;
+    cbData->cond->notify_all();
+    TRACE_L1("end");
+}
+
+Client::Interface::Interface(std::string name): id_{std::move(name)}
+{
+    TRACE_L1("%s(%p)", id().c_str(), this);
+}
+
+Client::Interface::~Interface()
+{
+    TRACE_L1("%s(%p)", id().c_str(), this);
+}
+
+void Client::Interface::stateChange(int pid, AppState appState)
+{
+    TRACE_L1("id=%s(%p), pid=%d, %s", id().c_str(), this, pid, toStr(appState));
+    onStateChange(pid, appState);
+}
+
+bool Client::Interface::startContainer(
+    Client *client,
+    const std::string &cmd, const std::string &param, milliseconds timeout)
+{
+    TRACE_L1(
+        "id=%s(%p), cmd=%s, param=%s, timeout=%dms",
+        id().c_str(), this, cmd.c_str(), param.c_str(), int(timeout.count()));
+
+    CHECK(client);
+
+    if(!client)
+    {
+        TRACE_L1("id=%s(%p), invalid client",  id().c_str(), this);
+        return false;
+    }
+
+    auto cancellable = makeCancellable();
+    std::unique_lock<std::mutex> lock{client->mutex_};
+
+    if(!client->connectionResetIfNeeded(lock)) return false;
+
+    AsyncReadyCbData cbData
+    {
+        [&](GAsyncResult *result, GError **error)
+        {
+            return
+                container_ctrl_call_start_finish(client->dbus_.api, result, error);
+        },
+        client->mutex_,
+        client->cond_
+    };
+
+    container_ctrl_call_start(
+        client->dbus_.api,
+        id().c_str(), cmd.c_str(), param.c_str(),
+        cancellable.get(), DBusCallbacks::asyncReady, &cbData);
+
+    const auto r =
+        client->waitForResult(lock, cbData.result, cancellable.get(), timeout);
+    TRACE_L1("result=%d", r);
+    return r;
+}
+
+bool Client::Interface::stopContainer(Client *client, milliseconds timeout)
+{
+    TRACE_L1("id=%s(%p), timeout=%dms", id().c_str(), this, int(timeout.count()));
+
+    CHECK(client);
+
+    if(!client)
+    {
+        TRACE_L1("id=%s(%p), invalid client",  id().c_str(), this);
+        return false;
+    }
+
+    auto cancellable = makeCancellable();
+    std::unique_lock<std::mutex> lock{client->mutex_};
+
+    if(!client->connectionResetIfNeeded(lock)) return false;
+
+    AsyncReadyCbData cbData
+    {
+        [&](GAsyncResult *result, GError **error)
+        {
+            return
+                container_ctrl_call_stop_finish(client->dbus_.api, result, error);
+        },
+        client->mutex_,
+        client->cond_
+    };
+
+    container_ctrl_call_stop(
+        client->dbus_.api,
+        id().c_str(),
+        cancellable.get(), DBusCallbacks::asyncReady, &cbData);
+
+    const auto r =
+        client->waitForResult(lock, cbData.result, cancellable.get(), timeout);
+    TRACE_L1("result=%d", r);
+    return r;
+}
+
+bool Client::connectionResetIfNeeded(Lock &lock, milliseconds timeout)
+{
+    if(ConnState::Pending == dbus_.connState)
+    {
+       TRACE_L1("wait for pending connection");
+
+       cond_.wait(
+          lock,
+          [&]()
+          {
+              if(ConnState::Pending != dbus_.connState) return true;
+              TRACE_L1("still waiting");
+              return false;
+          });
+    }
+
+    if(ConnState::Connected == dbus_.connState) return true;
+
+    CHECK(ConnState::Disconnected == dbus_.connState);
+
+    if(ConnState::Disconnected != dbus_.connState) return false;
+
+    CHECK(!dbus_.thread);
+
+    if(dbus_.thread) return false;
+
+    TRACE_L1("spawning dbus thread");
+
+    dbus_.thread =
+        std::unique_ptr<ThreadGuard>(new ThreadGuard{[=](){exec();}});
+
+    if(!connectBus(lock, timeout))
+    {
+        TRACE_L1("not connected, timeout=%dms", int(timeout.count()));
+        quit(lock);
+        /* wait until exec() returns */
+        dbus_.thread.reset(nullptr);
+        return false;
+    }
+
+    return true;
+}
+
+void Client::connect(gulong &signal, const char *name, GCallback callback)
+{
+    CHECK(!mutex_.try_lock());
+    CHECK(0 == signal);
+    if(0 != signal) return;
+    signal = g_signal_connect(dbus_.api, name, callback, this);
+}
+
+void Client::disconnect(gulong &signal)
+{
+    CHECK(!mutex_.try_lock());
+    CHECK(0 != signal);
+    if(0 == signal) return;
+    g_signal_handler_disconnect(dbus_.api, signal);
+    signal = 0;
+}
+
+bool Client::waitForResult(
+    Lock &lock, AsyncResult &result, GCancellable *cancellable, milliseconds timeout)
+{
+    TRACE_L1("begin, timeout=%d", int(timeout.count()));
+    CHECK(cancellable);
+
+    const auto status =
+        cond_.wait_for(lock, timeout, [&](){return result != AsyncResult::Pending;});
+
+    if(!status)
+    {
+        TRACE_L1("timeout: %dms", int(timeout.count()));
+
+        g_cancellable_cancel(cancellable);
+
+        /* must wait for:
+         * a) async operation to be cancelled (asyncReady wont be called)
+         * and:
+         * b) asyncReady finish executing
+         * because asyncReady uses AsyncReadyCbData from current thread stack */
+        cond_.wait(
+            lock, [&]()
+            {
+                return
+                    result != AsyncResult::Pending
+                    && g_cancellable_is_cancelled(cancellable);
+            });
+        TRACE_L1("cancelled async call");
+    }
+
+    const auto r = AsyncResult::OK == result;
+
+    TRACE_L1("end, result=%d", r);
+    return r;
+}
+
+bool Client::connectBus(Lock &lock, milliseconds timeout)
+{
+    CHECK(!dbus_.api);
+    if(dbus_.api) return false;
+
+    CHECK(ConnState::Disconnected == dbus_.connState);
+    if(ConnState::Disconnected != dbus_.connState) return false;
+
+    dbus_.connState = ConnState::Pending;
+
+    TRACE_L1("if=%s, path=%s", dbusInterface(), dbusPath());
+
+    AsyncReadyCbData cbData
+    {
+        [&](GAsyncResult *result, GError **error)
+        {
+            dbus_.api = container_ctrl_proxy_new_for_bus_finish(result, error);
+            return dbus_.api;
+        },
+        mutex_,
+        cond_
+    };
+
+    auto cancellable = makeCancellable();
+
+    container_ctrl_proxy_new_for_bus(
+        G_BUS_TYPE_SYSTEM,
+        G_DBUS_PROXY_FLAGS_NONE,
+        dbusInterface(),
+        dbusPath(),
+        cancellable.get(),
+        DBusCallbacks::asyncReady,
+        &cbData);
+
+    const auto status =
+        waitForResult(lock, cbData.result, cancellable.get(), timeout);
+
+    if(!status)
+    {
+        TRACE_L1("failed, timeout=%dms", int(timeout.count()));
+        dbus_.connState = ConnState::Disconnected;
+        CHECK(!dbus_.api);
+        return false;
+    }
+
+    TRACE_L1("connected");
+
+    connect(
+        dbus_.signalId.stateChange,
+        "state-change", G_CALLBACK(DBusCallbacks::handleStateChange));
+    dbus_.connState = ConnState::Connected;
+    return true;
+}
+
+void Client::disconnectBus(Lock &)
+{
+    if(ConnState::Connected != dbus_.connState) return;
+
+    disconnect(dbus_.signalId.stateChange);
+    dbus_.connState = ConnState::Disconnected;
+    g_object_unref(dbus_.api);
+    dbus_.api = nullptr;
+}
+
+void Client::exec()
+{
+    TRACE_L1("begin");
+
+    auto loopHandle =
+        std::unique_ptr<GMainLoop, decltype(&g_main_loop_unref)>
+        {
+            g_main_loop_new(nullptr, FALSE /* not running */),
+            g_main_loop_unref
+        };
+
+    {
+        std::unique_lock<std::mutex> lock(mutex_);
+        dbus_.mainLoop = loopHandle.get();
+    }
+
+    g_main_loop_run(loopHandle.get());
+
+    {
+        std::unique_lock<std::mutex> lock(mutex_);
+        dbus_.mainLoop = nullptr;
+        disconnectBus(lock);
+    }
+
+    TRACE_L1("end");
+}
+
+Client::SharedInterface Client::findInterface(const std::string &id)
+{
+    std::unique_lock<std::mutex> lock{mutex_};
+
+    const auto i = map_.find(id);
+
+    if(std::end(map_) == i) return nullptr;
+    return i->second;
+}
+
+void Client::quit(Lock &)
+{
+    TRACE_L1("%p", this);
+
+    if(!dbus_.mainLoop) return;
+    if(!g_main_loop_is_running(dbus_.mainLoop)) return;
+    g_main_loop_quit(dbus_.mainLoop);
+}
+
+Client::Client()
+{
+    TRACE_L1("%p", this);
+}
+
+Client::~Client()
+{
+    TRACE_L1("%p", this);
+    quit();
+}
+
+void Client::quit()
+{
+    TRACE_L1("%p", this);
+
+    std::unique_lock<std::mutex> lock(mutex_);
+    quit(lock);
+}
+
+bool Client::bind(SharedInterface interface)
+{
+    CHECK(interface);
+    CHECK(!interface->id().empty());
+
+    std::unique_lock<std::mutex> lock{mutex_};
+
+    CHECK(0u == map_.count(interface->id()));
+
+    if(
+        !interface
+        || interface->id().empty()
+        || 0u != map_.count(interface->id()))
+    {
+        TRACE_L1("failed to bind: %s(%p)", interface->id().c_str(), interface.get());
+        return false;
+    }
+
+    TRACE_L1("bound: %s(%p)", interface->id().c_str(), interface.get());
+    auto id = interface->id();
+    map_.insert({std::move(id), std::move(interface)});
+    return true;
+}
+
+bool Client::unbind(SharedInterface interface)
+{
+    CHECK(interface);
+    CHECK(!interface->id().empty());
+
+    std::unique_lock<std::mutex> lock{mutex_};
+
+    if(
+        !interface
+        || interface->id().empty()
+        || !map_.count(interface->id()))
+    {
+        TRACE_L1(
+            "invalid/not bound: %s(%p)",
+            interface ? interface->id().c_str() : "", interface.get());
+        return true;
+    }
+
+    const auto r = map_.erase(interface->id());
+
+    if(r) TRACE_L1("unbound: %s(%p)", interface->id().c_str(), interface.get());
+    return r;
+}
--- /dev/null
+++ b/Source/extensions/processcontainers/implementations/AWCImplementation/dbus/Client.h
@@ -0,0 +1,126 @@
+#pragma once
+
+#include <atomic>
+#include <condition_variable>
+#include <map>
+#include <memory>
+#include <mutex>
+#include <string>
+#include <thread>
+
+#include "api.h"
+
+namespace WPEFramework {
+namespace ProcessContainers {
+namespace dbus {
+
+/* Keep this enum in sync with awc_app_state_t:
+ * slauncher/client/AWCClient.h
+ * this file is not included to avoid slauncher dep. */
+enum class AppState
+{
+  STARTED = 0,
+  STOPPED = 1,
+  SUSPENDED = 2,
+  CLOSED = 3,
+  STARTING = 4,
+  STOPPING = 5,
+  SUSPENDING = 6,
+  UNKNOWN = 7
+};
+
+inline
+const char *toStr(AppState state)
+{
+    const char *str[] =
+    {
+        "STARTED",
+        "STOPPED",
+        "SUSPENDED",
+        "CLOSED",
+        "STARTING",
+        "STOPPING",
+        "SUSPENDING",
+        "UNKNOWN"
+    };
+    return
+        int(sizeof(str) / sizeof(str[0])) > int(state)
+        ? str[int(state)] : "undefined";
+}
+
+struct ThreadGuard
+{
+    std::thread thread;
+
+    template <typename ...Tn>
+    ThreadGuard(Tn &&... args): thread{std::forward<Tn>(args)...} {}
+    ~ThreadGuard() {if(thread.joinable()) thread.join();}
+};
+
+enum class AsyncResult {Pending, Timeout, OK, NOK};
+enum class ConnState {Pending, Connected, Disconnected};
+
+struct Client
+{
+    friend struct DBusCallbacks;
+
+    using milliseconds = std::chrono::milliseconds;
+
+    class Interface
+    {
+        friend class Client;
+    private:
+        const std::string id_;
+        virtual void onStateChange(int pid, AppState state) = 0;
+    public:
+        Interface(std::string);
+        virtual ~Interface();
+        Interface(const Interface &) = delete;
+        Interface &operator=(const Interface &) = delete;
+
+        const std::string &id() const {return id_;};
+        void stateChange(int, AppState);
+        bool startContainer(
+            Client *, const std::string &, const std::string &, milliseconds);
+        bool stopContainer(Client *, milliseconds);
+    };
+
+    using SharedInterface = std::shared_ptr<Interface>;
+private:
+    using Lock = std::unique_lock<std::mutex>;
+    using Map = std::map<std::string, SharedInterface>;
+
+    std::mutex mutex_;
+    std::condition_variable cond_;
+    struct {
+        std::unique_ptr<ThreadGuard> thread;
+        GMainLoop *mainLoop{nullptr};
+        ContainerCtrl *api{nullptr};
+        ConnState connState{ConnState::Disconnected};
+
+        struct {
+            gulong stateChange{0};
+        } signalId;
+    } dbus_;
+    Map map_;
+
+    void connect(gulong &, const char *, GCallback);
+    void disconnect(gulong &);
+    bool waitForResult(Lock &, AsyncResult &, GCancellable *, milliseconds);
+    bool connectionResetIfNeeded(Lock &, milliseconds = milliseconds{500});
+    bool connectBus(Lock &, milliseconds timeout);
+    void disconnectBus(Lock &);
+    void exec();
+    SharedInterface findInterface(const std::string &);
+    void quit(Lock &);
+public:
+    Client();
+    ~Client();
+    void quit();
+    bool bind(SharedInterface);
+    bool unbind(SharedInterface);
+};
+
+} /* dbus */
+} /* ProcessContainers */
+} /* WPEFramework */
--- /dev/null
+++ b/Source/extensions/processcontainers/implementations/AWCImplementation/dbus/api.c
@@ -0,0 +1,1375 @@
+/*
+ * Generated by gdbus-codegen 2.48.2. DO NOT EDIT.
+ *
+ * The license of this code is the same as for the source it was derived from.
+ */
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include "api.h"
+
+#include <string.h>
+#ifdef G_OS_UNIX
+#  include <gio/gunixfdlist.h>
+#endif
+
+typedef struct
+{
+  GDBusArgInfo parent_struct;
+  gboolean use_gvariant;
+} _ExtendedGDBusArgInfo;
+
+typedef struct
+{
+  GDBusMethodInfo parent_struct;
+  const gchar *signal_name;
+  gboolean pass_fdlist;
+} _ExtendedGDBusMethodInfo;
+
+typedef struct
+{
+  GDBusSignalInfo parent_struct;
+  const gchar *signal_name;
+} _ExtendedGDBusSignalInfo;
+
+typedef struct
+{
+  GDBusPropertyInfo parent_struct;
+  const gchar *hyphen_name;
+  gboolean use_gvariant;
+} _ExtendedGDBusPropertyInfo;
+
+typedef struct
+{
+  GDBusInterfaceInfo parent_struct;
+  const gchar *hyphen_name;
+} _ExtendedGDBusInterfaceInfo;
+
+typedef struct
+{
+  const _ExtendedGDBusPropertyInfo *info;
+  guint prop_id;
+  GValue orig_value; /* the value before the change */
+} ChangedProperty;
+
+static void
+_changed_property_free (ChangedProperty *data)
+{
+  g_value_unset (&data->orig_value);
+  g_free (data);
+}
+
+static gboolean
+_g_strv_equal0 (gchar **a, gchar **b)
+{
+  gboolean ret = FALSE;
+  guint n;
+  if (a == NULL && b == NULL)
+    {
+      ret = TRUE;
+      goto out;
+    }
+  if (a == NULL || b == NULL)
+    goto out;
+  if (g_strv_length (a) != g_strv_length (b))
+    goto out;
+  for (n = 0; a[n] != NULL; n++)
+    if (g_strcmp0 (a[n], b[n]) != 0)
+      goto out;
+  ret = TRUE;
+out:
+  return ret;
+}
+
+static gboolean
+_g_variant_equal0 (GVariant *a, GVariant *b)
+{
+  gboolean ret = FALSE;
+  if (a == NULL && b == NULL)
+    {
+      ret = TRUE;
+      goto out;
+    }
+  if (a == NULL || b == NULL)
+    goto out;
+  ret = g_variant_equal (a, b);
+out:
+  return ret;
+}
+
+G_GNUC_UNUSED static gboolean
+_g_value_equal (const GValue *a, const GValue *b)
+{
+  gboolean ret = FALSE;
+  g_assert (G_VALUE_TYPE (a) == G_VALUE_TYPE (b));
+  switch (G_VALUE_TYPE (a))
+    {
+      case G_TYPE_BOOLEAN:
+        ret = (g_value_get_boolean (a) == g_value_get_boolean (b));
+        break;
+      case G_TYPE_UCHAR:
+        ret = (g_value_get_uchar (a) == g_value_get_uchar (b));
+        break;
+      case G_TYPE_INT:
+        ret = (g_value_get_int (a) == g_value_get_int (b));
+        break;
+      case G_TYPE_UINT:
+        ret = (g_value_get_uint (a) == g_value_get_uint (b));
+        break;
+      case G_TYPE_INT64:
+        ret = (g_value_get_int64 (a) == g_value_get_int64 (b));
+        break;
+      case G_TYPE_UINT64:
+        ret = (g_value_get_uint64 (a) == g_value_get_uint64 (b));
+        break;
+      case G_TYPE_DOUBLE:
+        {
+          /* Avoid -Wfloat-equal warnings by doing a direct bit compare */
+          gdouble da = g_value_get_double (a);
+          gdouble db = g_value_get_double (b);
+          ret = memcmp (&da, &db, sizeof (gdouble)) == 0;
+        }
+        break;
+      case G_TYPE_STRING:
+        ret = (g_strcmp0 (g_value_get_string (a), g_value_get_string (b)) == 0);
+        break;
+      case G_TYPE_VARIANT:
+        ret = _g_variant_equal0 (g_value_get_variant (a), g_value_get_variant (b));
+        break;
+      default:
+        if (G_VALUE_TYPE (a) == G_TYPE_STRV)
+          ret = _g_strv_equal0 (g_value_get_boxed (a), g_value_get_boxed (b));
+        else
+          g_critical ("_g_value_equal() does not handle type %s", g_type_name (G_VALUE_TYPE (a)));
+        break;
+    }
+  return ret;
+}
+
+/* ------------------------------------------------------------------------
+ * Code for interface com.lgi.rdk.utils.container.ctrl
+ * ------------------------------------------------------------------------
+ */
+
+/**
+ * SECTION:ContainerCtrl
+ * @title: ContainerCtrl
+ * @short_description: Generated C code for the com.lgi.rdk.utils.container.ctrl D-Bus interface
+ *
+ * This section contains code for working with the <link linkend="gdbus-interface-com-lgi-rdk-utils-container-ctrl.top_of_page">com.lgi.rdk.utils.container.ctrl</link> D-Bus interface in C.
+ */
+
+/* ---- Introspection data for com.lgi.rdk.utils.container.ctrl ---- */
+
+static const _ExtendedGDBusArgInfo _container_ctrl_method_info_start_IN_ARG_id =
+{
+  {
+    -1,
+    (gchar *) "id",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _container_ctrl_method_info_start_IN_ARG_cmd =
+{
+  {
+    -1,
+    (gchar *) "cmd",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _container_ctrl_method_info_start_IN_ARG_param =
+{
+  {
+    -1,
+    (gchar *) "param",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _container_ctrl_method_info_start_IN_ARG_pointers[] =
+{
+  &_container_ctrl_method_info_start_IN_ARG_id,
+  &_container_ctrl_method_info_start_IN_ARG_cmd,
+  &_container_ctrl_method_info_start_IN_ARG_param,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _container_ctrl_method_info_start =
+{
+  {
+    -1,
+    (gchar *) "Start",
+    (GDBusArgInfo **) &_container_ctrl_method_info_start_IN_ARG_pointers,
+    NULL,
+    NULL
+  },
+  "handle-start",
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _container_ctrl_method_info_stop_IN_ARG_id =
+{
+  {
+    -1,
+    (gchar *) "id",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _container_ctrl_method_info_stop_IN_ARG_pointers[] =
+{
+  &_container_ctrl_method_info_stop_IN_ARG_id,
+  NULL
+};
+
+static const _ExtendedGDBusMethodInfo _container_ctrl_method_info_stop =
+{
+  {
+    -1,
+    (gchar *) "Stop",
+    (GDBusArgInfo **) &_container_ctrl_method_info_stop_IN_ARG_pointers,
+    NULL,
+    NULL
+  },
+  "handle-stop",
+  FALSE
+};
+
+static const _ExtendedGDBusMethodInfo * const _container_ctrl_method_info_pointers[] =
+{
+  &_container_ctrl_method_info_start,
+  &_container_ctrl_method_info_stop,
+  NULL
+};
+
+static const _ExtendedGDBusArgInfo _container_ctrl_signal_info_state_change_ARG_id =
+{
+  {
+    -1,
+    (gchar *) "id",
+    (gchar *) "s",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _container_ctrl_signal_info_state_change_ARG_pid =
+{
+  {
+    -1,
+    (gchar *) "pid",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo _container_ctrl_signal_info_state_change_ARG_state =
+{
+  {
+    -1,
+    (gchar *) "state",
+    (gchar *) "i",
+    NULL
+  },
+  FALSE
+};
+
+static const _ExtendedGDBusArgInfo * const _container_ctrl_signal_info_state_change_ARG_pointers[] =
+{
+  &_container_ctrl_signal_info_state_change_ARG_id,
+  &_container_ctrl_signal_info_state_change_ARG_pid,
+  &_container_ctrl_signal_info_state_change_ARG_state,
+  NULL
+};
+
+static const _ExtendedGDBusSignalInfo _container_ctrl_signal_info_state_change =
+{
+  {
+    -1,
+    (gchar *) "StateChange",
+    (GDBusArgInfo **) &_container_ctrl_signal_info_state_change_ARG_pointers,
+    NULL
+  },
+  "state-change"
+};
+
+static const _ExtendedGDBusSignalInfo * const _container_ctrl_signal_info_pointers[] =
+{
+  &_container_ctrl_signal_info_state_change,
+  NULL
+};
+
+static const _ExtendedGDBusInterfaceInfo _container_ctrl_interface_info =
+{
+  {
+    -1,
+    (gchar *) "com.lgi.rdk.utils.container.ctrl",
+    (GDBusMethodInfo **) &_container_ctrl_method_info_pointers,
+    (GDBusSignalInfo **) &_container_ctrl_signal_info_pointers,
+    NULL,
+    NULL
+  },
+  "container-ctrl",
+};
+
+
+/**
+ * container_ctrl_interface_info:
+ *
+ * Gets a machine-readable description of the <link linkend="gdbus-interface-com-lgi-rdk-utils-container-ctrl.top_of_page">com.lgi.rdk.utils.container.ctrl</link> D-Bus interface.
+ *
+ * Returns: (transfer none): A #GDBusInterfaceInfo. Do not free.
+ */
+GDBusInterfaceInfo *
+container_ctrl_interface_info (void)
+{
+  return (GDBusInterfaceInfo *) &_container_ctrl_interface_info.parent_struct;
+}
+
+/**
+ * container_ctrl_override_properties:
+ * @klass: The class structure for a #GObject<!-- -->-derived class.
+ * @property_id_begin: The property id to assign to the first overridden property.
+ *
+ * Overrides all #GObject properties in the #ContainerCtrl interface for a concrete class.
+ * The properties are overridden in the order they are defined.
+ *
+ * Returns: The last property id.
+ */
+guint
+container_ctrl_override_properties (GObjectClass *klass, guint property_id_begin)
+{
+  return property_id_begin - 1;
+}
+
+
+
+/**
+ * ContainerCtrl:
+ *
+ * Abstract interface type for the D-Bus interface <link linkend="gdbus-interface-com-lgi-rdk-utils-container-ctrl.top_of_page">com.lgi.rdk.utils.container.ctrl</link>.
+ */
+
+/**
+ * ContainerCtrlIface:
+ * @parent_iface: The parent interface.
+ * @handle_start: Handler for the #ContainerCtrl::handle-start signal.
+ * @handle_stop: Handler for the #ContainerCtrl::handle-stop signal.
+ * @state_change: Handler for the #ContainerCtrl::state-change signal.
+ *
+ * Virtual table for the D-Bus interface <link linkend="gdbus-interface-com-lgi-rdk-utils-container-ctrl.top_of_page">com.lgi.rdk.utils.container.ctrl</link>.
+ */
+
+typedef ContainerCtrlIface ContainerCtrlInterface;
+G_DEFINE_INTERFACE (ContainerCtrl, container_ctrl, G_TYPE_OBJECT);
+
+static void
+container_ctrl_default_init (ContainerCtrlIface *iface)
+{
+  /* GObject signals for incoming D-Bus method calls: */
+  /**
+   * ContainerCtrl::handle-start:
+   * @object: A #ContainerCtrl.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_id: Argument passed by remote caller.
+   * @arg_cmd: Argument passed by remote caller.
+   * @arg_param: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-lgi-rdk-utils-container-ctrl.Start">Start()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call container_ctrl_complete_start() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-start",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (ContainerCtrlIface, handle_start),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    4,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING, G_TYPE_STRING, G_TYPE_STRING);
+
+  /**
+   * ContainerCtrl::handle-stop:
+   * @object: A #ContainerCtrl.
+   * @invocation: A #GDBusMethodInvocation.
+   * @arg_id: Argument passed by remote caller.
+   *
+   * Signal emitted when a remote caller is invoking the <link linkend="gdbus-method-com-lgi-rdk-utils-container-ctrl.Stop">Stop()</link> D-Bus method.
+   *
+   * If a signal handler returns %TRUE, it means the signal handler will handle the invocation (e.g. take a reference to @invocation and eventually call container_ctrl_complete_stop() or e.g. g_dbus_method_invocation_return_error() on it) and no order signal handlers will run. If no signal handler handles the invocation, the %G_DBUS_ERROR_UNKNOWN_METHOD error is returned.
+   *
+   * Returns: %TRUE if the invocation was handled, %FALSE to let other signal handlers run.
+   */
+  g_signal_new ("handle-stop",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (ContainerCtrlIface, handle_stop),
+    g_signal_accumulator_true_handled,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_BOOLEAN,
+    2,
+    G_TYPE_DBUS_METHOD_INVOCATION, G_TYPE_STRING);
+
+  /* GObject signals for received D-Bus signals: */
+  /**
+   * ContainerCtrl::state-change:
+   * @object: A #ContainerCtrl.
+   * @arg_id: Argument.
+   * @arg_pid: Argument.
+   * @arg_state: Argument.
+   *
+   * On the client-side, this signal is emitted whenever the D-Bus signal <link linkend="gdbus-signal-com-lgi-rdk-utils-container-ctrl.StateChange">"StateChange"</link> is received.
+   *
+   * On the service-side, this signal can be used with e.g. g_signal_emit_by_name() to make the object emit the D-Bus signal.
+   */
+  g_signal_new ("state-change",
+    G_TYPE_FROM_INTERFACE (iface),
+    G_SIGNAL_RUN_LAST,
+    G_STRUCT_OFFSET (ContainerCtrlIface, state_change),
+    NULL,
+    NULL,
+    g_cclosure_marshal_generic,
+    G_TYPE_NONE,
+    3, G_TYPE_STRING, G_TYPE_INT, G_TYPE_INT);
+
+}
+
+/**
+ * container_ctrl_emit_state_change:
+ * @object: A #ContainerCtrl.
+ * @arg_id: Argument to pass with the signal.
+ * @arg_pid: Argument to pass with the signal.
+ * @arg_state: Argument to pass with the signal.
+ *
+ * Emits the <link linkend="gdbus-signal-com-lgi-rdk-utils-container-ctrl.StateChange">"StateChange"</link> D-Bus signal.
+ */
+void
+container_ctrl_emit_state_change (
+    ContainerCtrl *object,
+    const gchar *arg_id,
+    gint arg_pid,
+    gint arg_state)
+{
+  g_signal_emit_by_name (object, "state-change", arg_id, arg_pid, arg_state);
+}
+
+/**
+ * container_ctrl_call_start:
+ * @proxy: A #ContainerCtrlProxy.
+ * @arg_id: Argument to pass with the method invocation.
+ * @arg_cmd: Argument to pass with the method invocation.
+ * @arg_param: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-com-lgi-rdk-utils-container-ctrl.Start">Start()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call container_ctrl_call_start_finish() to get the result of the operation.
+ *
+ * See container_ctrl_call_start_sync() for the synchronous, blocking version of this method.
+ */
+void
+container_ctrl_call_start (
+    ContainerCtrl *proxy,
+    const gchar *arg_id,
+    const gchar *arg_cmd,
+    const gchar *arg_param,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "Start",
+    g_variant_new ("(sss)",
+                   arg_id,
+                   arg_cmd,
+                   arg_param),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * container_ctrl_call_start_finish:
+ * @proxy: A #ContainerCtrlProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to container_ctrl_call_start().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with container_ctrl_call_start().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+container_ctrl_call_start_finish (
+    ContainerCtrl *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * container_ctrl_call_start_sync:
+ * @proxy: A #ContainerCtrlProxy.
+ * @arg_id: Argument to pass with the method invocation.
+ * @arg_cmd: Argument to pass with the method invocation.
+ * @arg_param: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-com-lgi-rdk-utils-container-ctrl.Start">Start()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See container_ctrl_call_start() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+container_ctrl_call_start_sync (
+    ContainerCtrl *proxy,
+    const gchar *arg_id,
+    const gchar *arg_cmd,
+    const gchar *arg_param,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "Start",
+    g_variant_new ("(sss)",
+                   arg_id,
+                   arg_cmd,
+                   arg_param),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * container_ctrl_call_stop:
+ * @proxy: A #ContainerCtrlProxy.
+ * @arg_id: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied or %NULL.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously invokes the <link linkend="gdbus-method-com-lgi-rdk-utils-container-ctrl.Stop">Stop()</link> D-Bus method on @proxy.
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call container_ctrl_call_stop_finish() to get the result of the operation.
+ *
+ * See container_ctrl_call_stop_sync() for the synchronous, blocking version of this method.
+ */
+void
+container_ctrl_call_stop (
+    ContainerCtrl *proxy,
+    const gchar *arg_id,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data)
+{
+  g_dbus_proxy_call (G_DBUS_PROXY (proxy),
+    "Stop",
+    g_variant_new ("(s)",
+                   arg_id),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    callback,
+    user_data);
+}
+
+/**
+ * container_ctrl_call_stop_finish:
+ * @proxy: A #ContainerCtrlProxy.
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to container_ctrl_call_stop().
+ * @error: Return location for error or %NULL.
+ *
+ * Finishes an operation started with container_ctrl_call_stop().
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+container_ctrl_call_stop_finish (
+    ContainerCtrl *proxy,
+    GAsyncResult *res,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_finish (G_DBUS_PROXY (proxy), res, error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * container_ctrl_call_stop_sync:
+ * @proxy: A #ContainerCtrlProxy.
+ * @arg_id: Argument to pass with the method invocation.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL.
+ *
+ * Synchronously invokes the <link linkend="gdbus-method-com-lgi-rdk-utils-container-ctrl.Stop">Stop()</link> D-Bus method on @proxy. The calling thread is blocked until a reply is received.
+ *
+ * See container_ctrl_call_stop() for the asynchronous version of this method.
+ *
+ * Returns: (skip): %TRUE if the call succeded, %FALSE if @error is set.
+ */
+gboolean
+container_ctrl_call_stop_sync (
+    ContainerCtrl *proxy,
+    const gchar *arg_id,
+    GCancellable *cancellable,
+    GError **error)
+{
+  GVariant *_ret;
+  _ret = g_dbus_proxy_call_sync (G_DBUS_PROXY (proxy),
+    "Stop",
+    g_variant_new ("(s)",
+                   arg_id),
+    G_DBUS_CALL_FLAGS_NONE,
+    -1,
+    cancellable,
+    error);
+  if (_ret == NULL)
+    goto _out;
+  g_variant_get (_ret,
+                 "()");
+  g_variant_unref (_ret);
+_out:
+  return _ret != NULL;
+}
+
+/**
+ * container_ctrl_complete_start:
+ * @object: A #ContainerCtrl.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-lgi-rdk-utils-container-ctrl.Start">Start()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+container_ctrl_complete_start (
+    ContainerCtrl *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/**
+ * container_ctrl_complete_stop:
+ * @object: A #ContainerCtrl.
+ * @invocation: (transfer full): A #GDBusMethodInvocation.
+ *
+ * Helper function used in service implementations to finish handling invocations of the <link linkend="gdbus-method-com-lgi-rdk-utils-container-ctrl.Stop">Stop()</link> D-Bus method. If you instead want to finish handling an invocation by returning an error, use g_dbus_method_invocation_return_error() or similar.
+ *
+ * This method will free @invocation, you cannot use it afterwards.
+ */
+void
+container_ctrl_complete_stop (
+    ContainerCtrl *object,
+    GDBusMethodInvocation *invocation)
+{
+  g_dbus_method_invocation_return_value (invocation,
+    g_variant_new ("()"));
+}
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * ContainerCtrlProxy:
+ *
+ * The #ContainerCtrlProxy structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * ContainerCtrlProxyClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #ContainerCtrlProxy.
+ */
+
+struct _ContainerCtrlProxyPrivate
+{
+  GData *qdata;
+};
+
+static void container_ctrl_proxy_iface_init (ContainerCtrlIface *iface);
+
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (ContainerCtrlProxy, container_ctrl_proxy, G_TYPE_DBUS_PROXY,
+                         G_ADD_PRIVATE (ContainerCtrlProxy)
+                         G_IMPLEMENT_INTERFACE (TYPE_CONTAINER_CTRL, container_ctrl_proxy_iface_init));
+
+#else
+G_DEFINE_TYPE_WITH_CODE (ContainerCtrlProxy, container_ctrl_proxy, G_TYPE_DBUS_PROXY,
+                         G_IMPLEMENT_INTERFACE (TYPE_CONTAINER_CTRL, container_ctrl_proxy_iface_init));
+
+#endif
+static void
+container_ctrl_proxy_finalize (GObject *object)
+{
+  ContainerCtrlProxy *proxy = CONTAINER_CTRL_PROXY (object);
+  g_datalist_clear (&proxy->priv->qdata);
+  G_OBJECT_CLASS (container_ctrl_proxy_parent_class)->finalize (object);
+}
+
+static void
+container_ctrl_proxy_get_property (GObject      *object,
+  guint         prop_id,
+  GValue       *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+}
+
+static void
+container_ctrl_proxy_set_property (GObject      *object,
+  guint         prop_id,
+  const GValue *value,
+  GParamSpec   *pspec G_GNUC_UNUSED)
+{
+}
+
+static void
+container_ctrl_proxy_g_signal (GDBusProxy *proxy,
+  const gchar *sender_name G_GNUC_UNUSED,
+  const gchar *signal_name,
+  GVariant *parameters)
+{
+  _ExtendedGDBusSignalInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  guint num_params;
+  guint n;
+  guint signal_id;
+  info = (_ExtendedGDBusSignalInfo *) g_dbus_interface_info_lookup_signal ((GDBusInterfaceInfo *) &_container_ctrl_interface_info.parent_struct, signal_name);
+  if (info == NULL)
+    return;
+  num_params = g_variant_n_children (parameters);
+  paramv = g_new0 (GValue, num_params + 1);
+  g_value_init (&paramv[0], TYPE_CONTAINER_CTRL);
+  g_value_set_object (&paramv[0], proxy);
+  g_variant_iter_init (&iter, parameters);
+  n = 1;
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.args[n - 1];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, TYPE_CONTAINER_CTRL);
+  g_signal_emitv (paramv, signal_id, 0, NULL);
+  for (n = 0; n < num_params + 1; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static void
+container_ctrl_proxy_g_properties_changed (GDBusProxy *_proxy,
+  GVariant *changed_properties,
+  const gchar *const *invalidated_properties)
+{
+  ContainerCtrlProxy *proxy = CONTAINER_CTRL_PROXY (_proxy);
+  guint n;
+  const gchar *key;
+  GVariantIter *iter;
+  _ExtendedGDBusPropertyInfo *info;
+  g_variant_get (changed_properties, "a{sv}", &iter);
+  while (g_variant_iter_next (iter, "{&sv}", &key, NULL))
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_container_ctrl_interface_info.parent_struct, key);
+      g_datalist_remove_data (&proxy->priv->qdata, key);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+  g_variant_iter_free (iter);
+  for (n = 0; invalidated_properties[n] != NULL; n++)
+    {
+      info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_container_ctrl_interface_info.parent_struct, invalidated_properties[n]);
+      g_datalist_remove_data (&proxy->priv->qdata, invalidated_properties[n]);
+      if (info != NULL)
+        g_object_notify (G_OBJECT (proxy), info->hyphen_name);
+    }
+}
+
+static void
+container_ctrl_proxy_init (ContainerCtrlProxy *proxy)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  proxy->priv = container_ctrl_proxy_get_instance_private (proxy);
+#else
+  proxy->priv = G_TYPE_INSTANCE_GET_PRIVATE (proxy, TYPE_CONTAINER_CTRL_PROXY, ContainerCtrlProxyPrivate);
+#endif
+
+  g_dbus_proxy_set_interface_info (G_DBUS_PROXY (proxy), container_ctrl_interface_info ());
+}
+
+static void
+container_ctrl_proxy_class_init (ContainerCtrlProxyClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusProxyClass *proxy_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize     = container_ctrl_proxy_finalize;
+  gobject_class->get_property = container_ctrl_proxy_get_property;
+  gobject_class->set_property = container_ctrl_proxy_set_property;
+
+  proxy_class = G_DBUS_PROXY_CLASS (klass);
+  proxy_class->g_signal = container_ctrl_proxy_g_signal;
+  proxy_class->g_properties_changed = container_ctrl_proxy_g_properties_changed;
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (ContainerCtrlProxyPrivate));
+#endif
+}
+
+static void
+container_ctrl_proxy_iface_init (ContainerCtrlIface *iface)
+{
+}
+
+/**
+ * container_ctrl_proxy_new:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Asynchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-com-lgi-rdk-utils-container-ctrl.top_of_page">com.lgi.rdk.utils.container.ctrl</link>. See g_dbus_proxy_new() for more details.
+ *
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call container_ctrl_proxy_new_finish() to get the result of the operation.
+ *
+ * See container_ctrl_proxy_new_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+container_ctrl_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (TYPE_CONTAINER_CTRL_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "com.lgi.rdk.utils.container.ctrl", NULL);
+}
+
+/**
+ * container_ctrl_proxy_new_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to container_ctrl_proxy_new().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with container_ctrl_proxy_new().
+ *
+ * Returns: (transfer full) (type ContainerCtrlProxy): The constructed proxy object or %NULL if @error is set.
+ */
+ContainerCtrl *
+container_ctrl_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return CONTAINER_CTRL (ret);
+  else
+    return NULL;
+}
+
+/**
+ * container_ctrl_proxy_new_sync:
+ * @connection: A #GDBusConnection.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: (allow-none): A bus name (well-known or unique) or %NULL if @connection is not a message bus connection.
+ * @object_path: An object path.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Synchronously creates a proxy for the D-Bus interface <link linkend="gdbus-interface-com-lgi-rdk-utils-container-ctrl.top_of_page">com.lgi.rdk.utils.container.ctrl</link>. See g_dbus_proxy_new_sync() for more details.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See container_ctrl_proxy_new() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type ContainerCtrlProxy): The constructed proxy object or %NULL if @error is set.
+ */
+ContainerCtrl *
+container_ctrl_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (TYPE_CONTAINER_CTRL_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-connection", connection, "g-object-path", object_path, "g-interface-name", "com.lgi.rdk.utils.container.ctrl", NULL);
+  if (ret != NULL)
+    return CONTAINER_CTRL (ret);
+  else
+    return NULL;
+}
+
+
+/**
+ * container_ctrl_proxy_new_for_bus:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @callback: A #GAsyncReadyCallback to call when the request is satisfied.
+ * @user_data: User data to pass to @callback.
+ *
+ * Like container_ctrl_proxy_new() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * When the operation is finished, @callback will be invoked in the <link linkend="g-main-context-push-thread-default">thread-default main loop</link> of the thread you are calling this method from.
+ * You can then call container_ctrl_proxy_new_for_bus_finish() to get the result of the operation.
+ *
+ * See container_ctrl_proxy_new_for_bus_sync() for the synchronous, blocking version of this constructor.
+ */
+void
+container_ctrl_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data)
+{
+  g_async_initable_new_async (TYPE_CONTAINER_CTRL_PROXY, G_PRIORITY_DEFAULT, cancellable, callback, user_data, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "com.lgi.rdk.utils.container.ctrl", NULL);
+}
+
+/**
+ * container_ctrl_proxy_new_for_bus_finish:
+ * @res: The #GAsyncResult obtained from the #GAsyncReadyCallback passed to container_ctrl_proxy_new_for_bus().
+ * @error: Return location for error or %NULL
+ *
+ * Finishes an operation started with container_ctrl_proxy_new_for_bus().
+ *
+ * Returns: (transfer full) (type ContainerCtrlProxy): The constructed proxy object or %NULL if @error is set.
+ */
+ContainerCtrl *
+container_ctrl_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error)
+{
+  GObject *ret;
+  GObject *source_object;
+  source_object = g_async_result_get_source_object (res);
+  ret = g_async_initable_new_finish (G_ASYNC_INITABLE (source_object), res, error);
+  g_object_unref (source_object);
+  if (ret != NULL)
+    return CONTAINER_CTRL (ret);
+  else
+    return NULL;
+}
+
+/**
+ * container_ctrl_proxy_new_for_bus_sync:
+ * @bus_type: A #GBusType.
+ * @flags: Flags from the #GDBusProxyFlags enumeration.
+ * @name: A bus name (well-known or unique).
+ * @object_path: An object path.
+ * @cancellable: (allow-none): A #GCancellable or %NULL.
+ * @error: Return location for error or %NULL
+ *
+ * Like container_ctrl_proxy_new_sync() but takes a #GBusType instead of a #GDBusConnection.
+ *
+ * The calling thread is blocked until a reply is received.
+ *
+ * See container_ctrl_proxy_new_for_bus() for the asynchronous version of this constructor.
+ *
+ * Returns: (transfer full) (type ContainerCtrlProxy): The constructed proxy object or %NULL if @error is set.
+ */
+ContainerCtrl *
+container_ctrl_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error)
+{
+  GInitable *ret;
+  ret = g_initable_new (TYPE_CONTAINER_CTRL_PROXY, cancellable, error, "g-flags", flags, "g-name", name, "g-bus-type", bus_type, "g-object-path", object_path, "g-interface-name", "com.lgi.rdk.utils.container.ctrl", NULL);
+  if (ret != NULL)
+    return CONTAINER_CTRL (ret);
+  else
+    return NULL;
+}
+
+
+/* ------------------------------------------------------------------------ */
+
+/**
+ * ContainerCtrlSkeleton:
+ *
+ * The #ContainerCtrlSkeleton structure contains only private data and should only be accessed using the provided API.
+ */
+
+/**
+ * ContainerCtrlSkeletonClass:
+ * @parent_class: The parent class.
+ *
+ * Class structure for #ContainerCtrlSkeleton.
+ */
+
+struct _ContainerCtrlSkeletonPrivate
+{
+  GValue *properties;
+  GList *changed_properties;
+  GSource *changed_properties_idle_source;
+  GMainContext *context;
+  GMutex lock;
+};
+
+static void
+_container_ctrl_skeleton_handle_method_call (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name,
+  const gchar *method_name,
+  GVariant *parameters,
+  GDBusMethodInvocation *invocation,
+  gpointer user_data)
+{
+  ContainerCtrlSkeleton *skeleton = CONTAINER_CTRL_SKELETON (user_data);
+  _ExtendedGDBusMethodInfo *info;
+  GVariantIter iter;
+  GVariant *child;
+  GValue *paramv;
+  guint num_params;
+  guint num_extra;
+  guint n;
+  guint signal_id;
+  GValue return_value = G_VALUE_INIT;
+  info = (_ExtendedGDBusMethodInfo *) g_dbus_method_invocation_get_method_info (invocation);
+  g_assert (info != NULL);
+  num_params = g_variant_n_children (parameters);
+  num_extra = info->pass_fdlist ? 3 : 2;  paramv = g_new0 (GValue, num_params + num_extra);
+  n = 0;
+  g_value_init (&paramv[n], TYPE_CONTAINER_CTRL);
+  g_value_set_object (&paramv[n++], skeleton);
+  g_value_init (&paramv[n], G_TYPE_DBUS_METHOD_INVOCATION);
+  g_value_set_object (&paramv[n++], invocation);
+  if (info->pass_fdlist)
+    {
+#ifdef G_OS_UNIX
+      g_value_init (&paramv[n], G_TYPE_UNIX_FD_LIST);
+      g_value_set_object (&paramv[n++], g_dbus_message_get_unix_fd_list (g_dbus_method_invocation_get_message (invocation)));
+#else
+      g_assert_not_reached ();
+#endif
+    }
+  g_variant_iter_init (&iter, parameters);
+  while ((child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      _ExtendedGDBusArgInfo *arg_info = (_ExtendedGDBusArgInfo *) info->parent_struct.in_args[n - num_extra];
+      if (arg_info->use_gvariant)
+        {
+          g_value_init (&paramv[n], G_TYPE_VARIANT);
+          g_value_set_variant (&paramv[n], child);
+          n++;
+        }
+      else
+        g_dbus_gvariant_to_gvalue (child, &paramv[n++]);
+      g_variant_unref (child);
+    }
+  signal_id = g_signal_lookup (info->signal_name, TYPE_CONTAINER_CTRL);
+  g_value_init (&return_value, G_TYPE_BOOLEAN);
+  g_signal_emitv (paramv, signal_id, 0, &return_value);
+  if (!g_value_get_boolean (&return_value))
+    g_dbus_method_invocation_return_error (invocation, G_DBUS_ERROR, G_DBUS_ERROR_UNKNOWN_METHOD, "Method %s is not implemented on interface %s", method_name, interface_name);
+  g_value_unset (&return_value);
+  for (n = 0; n < num_params + num_extra; n++)
+    g_value_unset (&paramv[n]);
+  g_free (paramv);
+}
+
+static GVariant *
+_container_ctrl_skeleton_handle_get_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GError **error,
+  gpointer user_data)
+{
+  ContainerCtrlSkeleton *skeleton = CONTAINER_CTRL_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  GVariant *ret;
+  ret = NULL;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_container_ctrl_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      g_value_init (&value, pspec->value_type);
+      g_object_get_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      ret = g_dbus_gvalue_to_gvariant (&value, G_VARIANT_TYPE (info->parent_struct.signature));
+      g_value_unset (&value);
+    }
+  return ret;
+}
+
+static gboolean
+_container_ctrl_skeleton_handle_set_property (
+  GDBusConnection *connection G_GNUC_UNUSED,
+  const gchar *sender G_GNUC_UNUSED,
+  const gchar *object_path G_GNUC_UNUSED,
+  const gchar *interface_name G_GNUC_UNUSED,
+  const gchar *property_name,
+  GVariant *variant,
+  GError **error,
+  gpointer user_data)
+{
+  ContainerCtrlSkeleton *skeleton = CONTAINER_CTRL_SKELETON (user_data);
+  GValue value = G_VALUE_INIT;
+  GParamSpec *pspec;
+  _ExtendedGDBusPropertyInfo *info;
+  gboolean ret;
+  ret = FALSE;
+  info = (_ExtendedGDBusPropertyInfo *) g_dbus_interface_info_lookup_property ((GDBusInterfaceInfo *) &_container_ctrl_interface_info.parent_struct, property_name);
+  g_assert (info != NULL);
+  pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (skeleton), info->hyphen_name);
+  if (pspec == NULL)
+    {
+      g_set_error (error, G_DBUS_ERROR, G_DBUS_ERROR_INVALID_ARGS, "No property with name %s", property_name);
+    }
+  else
+    {
+      if (info->use_gvariant)
+        g_value_set_variant (&value, variant);
+      else
+        g_dbus_gvariant_to_gvalue (variant, &value);
+      g_object_set_property (G_OBJECT (skeleton), info->hyphen_name, &value);
+      g_value_unset (&value);
+      ret = TRUE;
+    }
+  return ret;
+}
+
+static const GDBusInterfaceVTable _container_ctrl_skeleton_vtable =
+{
+  _container_ctrl_skeleton_handle_method_call,
+  _container_ctrl_skeleton_handle_get_property,
+  _container_ctrl_skeleton_handle_set_property,
+  {NULL}
+};
+
+static GDBusInterfaceInfo *
+container_ctrl_skeleton_dbus_interface_get_info (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return container_ctrl_interface_info ();
+}
+
+static GDBusInterfaceVTable *
+container_ctrl_skeleton_dbus_interface_get_vtable (GDBusInterfaceSkeleton *skeleton G_GNUC_UNUSED)
+{
+  return (GDBusInterfaceVTable *) &_container_ctrl_skeleton_vtable;
+}
+
+static GVariant *
+container_ctrl_skeleton_dbus_interface_get_properties (GDBusInterfaceSkeleton *_skeleton)
+{
+  ContainerCtrlSkeleton *skeleton = CONTAINER_CTRL_SKELETON (_skeleton);
+
+  GVariantBuilder builder;
+  guint n;
+  g_variant_builder_init (&builder, G_VARIANT_TYPE ("a{sv}"));
+  if (_container_ctrl_interface_info.parent_struct.properties == NULL)
+    goto out;
+  for (n = 0; _container_ctrl_interface_info.parent_struct.properties[n] != NULL; n++)
+    {
+      GDBusPropertyInfo *info = _container_ctrl_interface_info.parent_struct.properties[n];
+      if (info->flags & G_DBUS_PROPERTY_INFO_FLAGS_READABLE)
+        {
+          GVariant *value;
+          value = _container_ctrl_skeleton_handle_get_property (g_dbus_interface_skeleton_get_connection (G_DBUS_INTERFACE_SKELETON (skeleton)), NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "com.lgi.rdk.utils.container.ctrl", info->name, NULL, skeleton);
+          if (value != NULL)
+            {
+              g_variant_take_ref (value);
+              g_variant_builder_add (&builder, "{sv}", info->name, value);
+              g_variant_unref (value);
+            }
+        }
+    }
+out:
+  return g_variant_builder_end (&builder);
+}
+
+static void
+container_ctrl_skeleton_dbus_interface_flush (GDBusInterfaceSkeleton *_skeleton)
+{
+}
+
+static void
+_container_ctrl_on_signal_state_change (
+    ContainerCtrl *object,
+    const gchar *arg_id,
+    gint arg_pid,
+    gint arg_state)
+{
+  ContainerCtrlSkeleton *skeleton = CONTAINER_CTRL_SKELETON (object);
+
+  GList      *connections, *l;
+  GVariant   *signal_variant;
+  connections = g_dbus_interface_skeleton_get_connections (G_DBUS_INTERFACE_SKELETON (skeleton));
+
+  signal_variant = g_variant_ref_sink (g_variant_new ("(sii)",
+                   arg_id,
+                   arg_pid,
+                   arg_state));
+  for (l = connections; l != NULL; l = l->next)
+    {
+      GDBusConnection *connection = l->data;
+      g_dbus_connection_emit_signal (connection,
+        NULL, g_dbus_interface_skeleton_get_object_path (G_DBUS_INTERFACE_SKELETON (skeleton)), "com.lgi.rdk.utils.container.ctrl", "StateChange",
+        signal_variant, NULL);
+    }
+  g_variant_unref (signal_variant);
+  g_list_free_full (connections, g_object_unref);
+}
+
+static void container_ctrl_skeleton_iface_init (ContainerCtrlIface *iface);
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+G_DEFINE_TYPE_WITH_CODE (ContainerCtrlSkeleton, container_ctrl_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_ADD_PRIVATE (ContainerCtrlSkeleton)
+                         G_IMPLEMENT_INTERFACE (TYPE_CONTAINER_CTRL, container_ctrl_skeleton_iface_init));
+
+#else
+G_DEFINE_TYPE_WITH_CODE (ContainerCtrlSkeleton, container_ctrl_skeleton, G_TYPE_DBUS_INTERFACE_SKELETON,
+                         G_IMPLEMENT_INTERFACE (TYPE_CONTAINER_CTRL, container_ctrl_skeleton_iface_init));
+
+#endif
+static void
+container_ctrl_skeleton_finalize (GObject *object)
+{
+  ContainerCtrlSkeleton *skeleton = CONTAINER_CTRL_SKELETON (object);
+  g_list_free_full (skeleton->priv->changed_properties, (GDestroyNotify) _changed_property_free);
+  if (skeleton->priv->changed_properties_idle_source != NULL)
+    g_source_destroy (skeleton->priv->changed_properties_idle_source);
+  g_main_context_unref (skeleton->priv->context);
+  g_mutex_clear (&skeleton->priv->lock);
+  G_OBJECT_CLASS (container_ctrl_skeleton_parent_class)->finalize (object);
+}
+
+static void
+container_ctrl_skeleton_init (ContainerCtrlSkeleton *skeleton)
+{
+#if GLIB_VERSION_MAX_ALLOWED >= GLIB_VERSION_2_38
+  skeleton->priv = container_ctrl_skeleton_get_instance_private (skeleton);
+#else
+  skeleton->priv = G_TYPE_INSTANCE_GET_PRIVATE (skeleton, TYPE_CONTAINER_CTRL_SKELETON, ContainerCtrlSkeletonPrivate);
+#endif
+
+  g_mutex_init (&skeleton->priv->lock);
+  skeleton->priv->context = g_main_context_ref_thread_default ();
+}
+
+static void
+container_ctrl_skeleton_class_init (ContainerCtrlSkeletonClass *klass)
+{
+  GObjectClass *gobject_class;
+  GDBusInterfaceSkeletonClass *skeleton_class;
+
+  gobject_class = G_OBJECT_CLASS (klass);
+  gobject_class->finalize = container_ctrl_skeleton_finalize;
+
+  skeleton_class = G_DBUS_INTERFACE_SKELETON_CLASS (klass);
+  skeleton_class->get_info = container_ctrl_skeleton_dbus_interface_get_info;
+  skeleton_class->get_properties = container_ctrl_skeleton_dbus_interface_get_properties;
+  skeleton_class->flush = container_ctrl_skeleton_dbus_interface_flush;
+  skeleton_class->get_vtable = container_ctrl_skeleton_dbus_interface_get_vtable;
+
+#if GLIB_VERSION_MAX_ALLOWED < GLIB_VERSION_2_38
+  g_type_class_add_private (klass, sizeof (ContainerCtrlSkeletonPrivate));
+#endif
+}
+
+static void
+container_ctrl_skeleton_iface_init (ContainerCtrlIface *iface)
+{
+  iface->state_change = _container_ctrl_on_signal_state_change;
+}
+
+/**
+ * container_ctrl_skeleton_new:
+ *
+ * Creates a skeleton object for the D-Bus interface <link linkend="gdbus-interface-com-lgi-rdk-utils-container-ctrl.top_of_page">com.lgi.rdk.utils.container.ctrl</link>.
+ *
+ * Returns: (transfer full) (type ContainerCtrlSkeleton): The skeleton object.
+ */
+ContainerCtrl *
+container_ctrl_skeleton_new (void)
+{
+  return CONTAINER_CTRL (g_object_new (TYPE_CONTAINER_CTRL_SKELETON, NULL));
+}
+
--- /dev/null
+++ b/Source/extensions/processcontainers/implementations/AWCImplementation/dbus/api.h
@@ -0,0 +1,227 @@
+/*
+ * Generated by gdbus-codegen 2.48.2. DO NOT EDIT.
+ *
+ * The license of this code is the same as for the source it was derived from.
+ */
+
+#ifndef __API_H__
+#define __API_H__
+
+#include <gio/gio.h>
+
+G_BEGIN_DECLS
+
+
+/* ------------------------------------------------------------------------ */
+/* Declarations for com.lgi.rdk.utils.container.ctrl */
+
+#define TYPE_CONTAINER_CTRL (container_ctrl_get_type ())
+#define CONTAINER_CTRL(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_CONTAINER_CTRL, ContainerCtrl))
+#define IS_CONTAINER_CTRL(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_CONTAINER_CTRL))
+#define CONTAINER_CTRL_GET_IFACE(o) (G_TYPE_INSTANCE_GET_INTERFACE ((o), TYPE_CONTAINER_CTRL, ContainerCtrlIface))
+
+struct _ContainerCtrl;
+typedef struct _ContainerCtrl ContainerCtrl;
+typedef struct _ContainerCtrlIface ContainerCtrlIface;
+
+struct _ContainerCtrlIface
+{
+  GTypeInterface parent_iface;
+
+
+  gboolean (*handle_start) (
+    ContainerCtrl *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_id,
+    const gchar *arg_cmd,
+    const gchar *arg_param);
+
+  gboolean (*handle_stop) (
+    ContainerCtrl *object,
+    GDBusMethodInvocation *invocation,
+    const gchar *arg_id);
+
+  void (*state_change) (
+    ContainerCtrl *object,
+    const gchar *arg_id,
+    gint arg_pid,
+    gint arg_state);
+
+};
+
+GType container_ctrl_get_type (void) G_GNUC_CONST;
+
+GDBusInterfaceInfo *container_ctrl_interface_info (void);
+guint container_ctrl_override_properties (GObjectClass *klass, guint property_id_begin);
+
+
+/* D-Bus method call completion functions: */
+void container_ctrl_complete_start (
+    ContainerCtrl *object,
+    GDBusMethodInvocation *invocation);
+
+void container_ctrl_complete_stop (
+    ContainerCtrl *object,
+    GDBusMethodInvocation *invocation);
+
+
+
+/* D-Bus signal emissions functions: */
+void container_ctrl_emit_state_change (
+    ContainerCtrl *object,
+    const gchar *arg_id,
+    gint arg_pid,
+    gint arg_state);
+
+
+
+/* D-Bus method calls: */
+void container_ctrl_call_start (
+    ContainerCtrl *proxy,
+    const gchar *arg_id,
+    const gchar *arg_cmd,
+    const gchar *arg_param,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean container_ctrl_call_start_finish (
+    ContainerCtrl *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean container_ctrl_call_start_sync (
+    ContainerCtrl *proxy,
+    const gchar *arg_id,
+    const gchar *arg_cmd,
+    const gchar *arg_param,
+    GCancellable *cancellable,
+    GError **error);
+
+void container_ctrl_call_stop (
+    ContainerCtrl *proxy,
+    const gchar *arg_id,
+    GCancellable *cancellable,
+    GAsyncReadyCallback callback,
+    gpointer user_data);
+
+gboolean container_ctrl_call_stop_finish (
+    ContainerCtrl *proxy,
+    GAsyncResult *res,
+    GError **error);
+
+gboolean container_ctrl_call_stop_sync (
+    ContainerCtrl *proxy,
+    const gchar *arg_id,
+    GCancellable *cancellable,
+    GError **error);
+
+
+
+/* ---- */
+
+#define TYPE_CONTAINER_CTRL_PROXY (container_ctrl_proxy_get_type ())
+#define CONTAINER_CTRL_PROXY(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_CONTAINER_CTRL_PROXY, ContainerCtrlProxy))
+#define CONTAINER_CTRL_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_CONTAINER_CTRL_PROXY, ContainerCtrlProxyClass))
+#define CONTAINER_CTRL_PROXY_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_CONTAINER_CTRL_PROXY, ContainerCtrlProxyClass))
+#define IS_CONTAINER_CTRL_PROXY(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_CONTAINER_CTRL_PROXY))
+#define IS_CONTAINER_CTRL_PROXY_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_CONTAINER_CTRL_PROXY))
+
+typedef struct _ContainerCtrlProxy ContainerCtrlProxy;
+typedef struct _ContainerCtrlProxyClass ContainerCtrlProxyClass;
+typedef struct _ContainerCtrlProxyPrivate ContainerCtrlProxyPrivate;
+
+struct _ContainerCtrlProxy
+{
+  /*< private >*/
+  GDBusProxy parent_instance;
+  ContainerCtrlProxyPrivate *priv;
+};
+
+struct _ContainerCtrlProxyClass
+{
+  GDBusProxyClass parent_class;
+};
+
+GType container_ctrl_proxy_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (ContainerCtrlProxy, g_object_unref)
+#endif
+
+void container_ctrl_proxy_new (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+ContainerCtrl *container_ctrl_proxy_new_finish (
+    GAsyncResult        *res,
+    GError             **error);
+ContainerCtrl *container_ctrl_proxy_new_sync (
+    GDBusConnection     *connection,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+void container_ctrl_proxy_new_for_bus (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GAsyncReadyCallback  callback,
+    gpointer             user_data);
+ContainerCtrl *container_ctrl_proxy_new_for_bus_finish (
+    GAsyncResult        *res,
+    GError             **error);
+ContainerCtrl *container_ctrl_proxy_new_for_bus_sync (
+    GBusType             bus_type,
+    GDBusProxyFlags      flags,
+    const gchar         *name,
+    const gchar         *object_path,
+    GCancellable        *cancellable,
+    GError             **error);
+
+
+/* ---- */
+
+#define TYPE_CONTAINER_CTRL_SKELETON (container_ctrl_skeleton_get_type ())
+#define CONTAINER_CTRL_SKELETON(o) (G_TYPE_CHECK_INSTANCE_CAST ((o), TYPE_CONTAINER_CTRL_SKELETON, ContainerCtrlSkeleton))
+#define CONTAINER_CTRL_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_CAST ((k), TYPE_CONTAINER_CTRL_SKELETON, ContainerCtrlSkeletonClass))
+#define CONTAINER_CTRL_SKELETON_GET_CLASS(o) (G_TYPE_INSTANCE_GET_CLASS ((o), TYPE_CONTAINER_CTRL_SKELETON, ContainerCtrlSkeletonClass))
+#define IS_CONTAINER_CTRL_SKELETON(o) (G_TYPE_CHECK_INSTANCE_TYPE ((o), TYPE_CONTAINER_CTRL_SKELETON))
+#define IS_CONTAINER_CTRL_SKELETON_CLASS(k) (G_TYPE_CHECK_CLASS_TYPE ((k), TYPE_CONTAINER_CTRL_SKELETON))
+
+typedef struct _ContainerCtrlSkeleton ContainerCtrlSkeleton;
+typedef struct _ContainerCtrlSkeletonClass ContainerCtrlSkeletonClass;
+typedef struct _ContainerCtrlSkeletonPrivate ContainerCtrlSkeletonPrivate;
+
+struct _ContainerCtrlSkeleton
+{
+  /*< private >*/
+  GDBusInterfaceSkeleton parent_instance;
+  ContainerCtrlSkeletonPrivate *priv;
+};
+
+struct _ContainerCtrlSkeletonClass
+{
+  GDBusInterfaceSkeletonClass parent_class;
+};
+
+GType container_ctrl_skeleton_get_type (void) G_GNUC_CONST;
+
+#if GLIB_CHECK_VERSION(2, 44, 0)
+G_DEFINE_AUTOPTR_CLEANUP_FUNC (ContainerCtrlSkeleton, g_object_unref)
+#endif
+
+ContainerCtrl *container_ctrl_skeleton_new (void);
+
+
+G_END_DECLS
+
+#endif /* __API_H__ */
--- /dev/null
+++ b/Source/extensions/processcontainers/implementations/AWCImplementation/dbus/api.xml
@@ -0,0 +1,21 @@
+<node>
+    <interface name="com.lgi.rdk.utils.container.ctrl">
+
+    <method name="Start">
+        <arg name="id" direction="in" type="s"/>
+        <arg name="cmd" direction="in" type="s"/>
+        <arg name="param" direction="in" type="s"/>
+    </method>
+
+    <method name="Stop">
+        <arg name="id" direction="in" type="s"/>
+    </method>
+
+    <signal name="StateChange">
+        <arg name="id" direction="out" type="s"/>
+        <arg name="pid" direction="out" type="i"/>
+        <arg name="state" direction="out" type="i"/>
+    </signal>
+
+</interface>
+</node>
--- /dev/null
+++ b/cmake/modules/FindDBus.cmake
@@ -0,0 +1,46 @@
+# If not stated otherwise in this file or this component's license file the
+# following copyright and licenses apply:
+#
+# Copyright 2020 RDK Management
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+FIND_PACKAGE(PkgConfig)
+PKG_CHECK_MODULES(PC_DBUS QUIET dbus-1)
+
+FIND_LIBRARY(DBUS_LIBRARIES
+    NAMES dbus-1
+    HINTS ${PC_DBUS_LIBDIR}
+          ${PC_DBUS_LIBRARY_DIRS}
+)
+
+FIND_PATH(DBUS_INCLUDE_DIR
+    NAMES dbus/dbus.h
+    HINTS ${PC_DBUS_INCLUDEDIR}
+          ${PC_DBUS_INCLUDE_DIRS}
+)
+
+GET_FILENAME_COMPONENT(_DBUS_LIBRARY_DIR ${DBUS_LIBRARIES} PATH)
+FIND_PATH(DBUS_ARCH_INCLUDE_DIR
+    NAMES dbus/dbus-arch-deps.h
+    HINTS ${PC_DBUS_INCLUDEDIR}
+          ${PC_DBUS_INCLUDE_DIRS}
+          ${_DBUS_LIBRARY_DIR}
+          ${DBUS_INCLUDE_DIR}
+    PATH_SUFFIXES include
+)
+
+SET(DBUS_INCLUDE_DIRS ${DBUS_INCLUDE_DIR} ${DBUS_ARCH_INCLUDE_DIR})
+
+INCLUDE(FindPackageHandleStandardArgs)
+FIND_PACKAGE_HANDLE_STANDARD_ARGS(DBUS REQUIRED_VARS DBUS_INCLUDE_DIRS DBUS_LIBRARIES)
--- /dev/null
+++ b/cmake/modules/FindDBusClient.cmake
@@ -0,0 +1,40 @@
+# If not stated otherwise in this file or this component's license file the
+# following copyright and licenses apply:
+#
+# Copyright 2020 RDK Management
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+# http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+find_package(PkgConfig)
+pkg_check_modules(PC_DBusClient dbus-client)
+
+if(${PC_DBusClient_FOUND})
+    find_library(DBusClient_LIBRARY dbus_client
+        HINTS ${PC_DBusClient_LIBDIR} ${PC_DBusClient_LIBRARY_DIRS} REQUIRED
+        )
+    find_path(DBusClient_INCLUDE DBusClient.h
+        PATH_SUFFIXES dbus-client
+        )
+
+    if(NOT TARGET DBusClient::DBusClient)
+        add_library(DBusClient::DBusClient UNKNOWN IMPORTED)
+
+        set_target_properties(DBusClient::DBusClient
+            PROPERTIES
+            IMPORTED_LINK_INTERFACE_LANGUAGES "CXX"
+            IMPORTED_LOCATION "${DBusClient_LIBRARY}"
+            INTERFACE_INCLUDE_DIRECTORIES "${DBusClient_INCLUDE}"
+            INTERFACE_LINK_LIBRARIES "${PC_DBusClient_LIBRARIES}"
+        )
+    endif()
+endif()
--- /dev/null
+++ b/cmake/modules/FindLibGio.cmake
@@ -0,0 +1,67 @@
+#============================================================================
+# Copyright (c) 2017 Liberty Global
+#============================================================================
+
+# - Try to find GIO
+#
+# Once done this will define
+#  LIBGIO_FOUND           - System has the component
+#  LIBGIO_INCLUDE_DIRS    - Component include directories
+#  LIBGIO_LIBRARIES       - Libraries needed to use the component
+
+# Use the pkgconfig
+find_package(PkgConfig REQUIRED)
+
+# Find the component information
+pkg_check_modules(PC_LIBGIO QUIET gio-2.0)
+
+# <XPREFIX>_FOUND          - set to 1 if module(s) exist
+# <XPREFIX>_LIBRARIES      - only the libraries (w/o the '-l')
+# <XPREFIX>_LIBRARY_DIRS   - the paths of the libraries (w/o the '-L')
+# <XPREFIX>_LDFLAGS        - all required linker flags
+# <XPREFIX>_LDFLAGS_OTHER  - all other linker flags
+# <XPREFIX>_INCLUDE_DIRS   - the '-I' preprocessor flags (w/o the '-I')
+# <XPREFIX>_CFLAGS         - all required cflags
+# <XPREFIX>_CFLAGS_OTHER   - the other compiler flags
+
+# <XPREFIX>_VERSION    - version of the module
+# <XPREFIX>_PREFIX     - prefix-directory of the module
+# <XPREFIX>_INCLUDEDIR - include-dir of the module
+# <XPREFIX>_LIBDIR     - lib-dir of the module
+
+message(STATUS "PC_LIBGIO_FOUND         = ${PC_LIBGIO_FOUND}")
+message(STATUS "PC_LIBGIO_LIBRARIES     = ${PC_LIBGIO_LIBRARIES}")
+message(STATUS "PC_LIBGIO_LIBRARY_DIRS  = ${PC_LIBGIO_LIBRARY_DIRS}")
+message(STATUS "PC_LIBGIO_LDFLAGS       = ${PC_LIBGIO_LDFLAGS}")
+message(STATUS "PC_LIBGIO_LDFLAGS_OTHER = ${PC_LIBGIO_LDFLAGS_OTHER}")
+message(STATUS "PC_LIBGIO_INCLUDE_DIRS  = ${PC_LIBGIO_INCLUDE_DIRS}")
+message(STATUS "PC_LIBGIO_CFLAGS        = ${PC_LIBGIO_CFLAGS}")
+message(STATUS "PC_LIBGIO_CFLAGS_OTHER  = ${PC_LIBGIO_CFLAGS_OTHER}")
+message(STATUS "PC_LIBGIO_VERSION       = ${PC_LIBGIO_VERSION}")
+message(STATUS "PC_LIBGIO_PREFIX        = ${PC_LIBGIO_PREFIX}")
+message(STATUS "PC_LIBGIO_INCLUDEDIR    = ${PC_LIBGIO_INCLUDEDIR}")
+message(STATUS "PC_LIBGIO_LIBDIR        = ${PC_LIBGIO_LIBDIR}")
+
+find_path(LIBGIO_INCLUDE_DIR
+          NAMES gio/gio.h
+          HINTS ${PC_LIBGIO_INCLUDEDIR} ${PC_LIBGIO_INCLUDE_DIRS}
+          PATH_SUFFIXES glib-2.0 )
+
+find_library(LIBGIO_LIBRARY
+             NAMES gio-2.0
+             HINTS ${PC_LIBGIO_LIBDIR} ${PC_LIBGIO_LIBRARY_DIRS} )
+
+message(STATUS "LIBGIO_INCLUDE_DIR           = ${LIBGIO_INCLUDE_DIR}")
+message(STATUS "LIBGIO_LIBRARY               = ${LIBGIO_LIBRARY}")
+
+# handle the QUIETLY and REQUIRED arguments and set component to TRUE
+# if all listed variables are TRUE
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(LibGio DEFAULT_MSG
+                                  LIBGIO_LIBRARY LIBGIO_INCLUDE_DIR)
+
+mark_as_advanced(LIBGIO_INCLUDE_DIR LIBGIO_LIBRARY)
+
+set(LIBGIO_INCLUDE_DIRS ${LIBGIO_INCLUDE_DIR})
+set(LIBGIO_LIBRARIES ${LIBGIO_LIBRARY})
+
--- /dev/null
+++ b/cmake/modules/FindLibGioUnix.cmake
@@ -0,0 +1,67 @@
+#============================================================================
+# Copyright (c) 2017 Liberty Global
+#============================================================================
+
+# - Try to find GIO-UNIX
+#
+# Once done this will define
+#  LIBGIOUNIX_FOUND           - System has the component
+#  LIBGIOUNIX_INCLUDE_DIRS    - Component include directories
+#  LIBGIOUNIX_LIBRARIES       - Libraries needed to use the component
+
+# Use the pkgconfig
+find_package(PkgConfig REQUIRED)
+
+# Find the component information
+pkg_check_modules(PC_LIBGIOUNIX QUIET gio-unix-2.0)
+
+# <XPREFIX>_FOUND          - set to 1 if module(s) exist
+# <XPREFIX>_LIBRARIES      - only the libraries (w/o the '-l')
+# <XPREFIX>_LIBRARY_DIRS   - the paths of the libraries (w/o the '-L')
+# <XPREFIX>_LDFLAGS        - all required linker flags
+# <XPREFIX>_LDFLAGS_OTHER  - all other linker flags
+# <XPREFIX>_INCLUDE_DIRS   - the '-I' preprocessor flags (w/o the '-I')
+# <XPREFIX>_CFLAGS         - all required cflags
+# <XPREFIX>_CFLAGS_OTHER   - the other compiler flags
+
+# <XPREFIX>_VERSION    - version of the module
+# <XPREFIX>_PREFIX     - prefix-directory of the module
+# <XPREFIX>_INCLUDEDIR - include-dir of the module
+# <XPREFIX>_LIBDIR     - lib-dir of the module
+
+message(STATUS "PC_LIBGIOUNIX_FOUND         = ${PC_LIBGIOUNIX_FOUND}")
+message(STATUS "PC_LIBGIOUNIX_LIBRARIES     = ${PC_LIBGIOUNIX_LIBRARIES}")
+message(STATUS "PC_LIBGIOUNIX_LIBRARY_DIRS  = ${PC_LIBGIOUNIX_LIBRARY_DIRS}")
+message(STATUS "PC_LIBGIOUNIX_LDFLAGS       = ${PC_LIBGIOUNIX_LDFLAGS}")
+message(STATUS "PC_LIBGIOUNIX_LDFLAGS_OTHER = ${PC_LIBGIOUNIX_LDFLAGS_OTHER}")
+message(STATUS "PC_LIBGIOUNIX_INCLUDE_DIRS  = ${PC_LIBGIOUNIX_INCLUDE_DIRS}")
+message(STATUS "PC_LIBGIOUNIX_CFLAGS        = ${PC_LIBGIOUNIX_CFLAGS}")
+message(STATUS "PC_LIBGIOUNIX_CFLAGS_OTHER  = ${PC_LIBGIOUNIX_CFLAGS_OTHER}")
+message(STATUS "PC_LIBGIOUNIX_VERSION       = ${PC_LIBGIOUNIX_VERSION}")
+message(STATUS "PC_LIBGIOUNIX_PREFIX        = ${PC_LIBGIOUNIX_PREFIX}")
+message(STATUS "PC_LIBGIOUNIX_INCLUDEDIR    = ${PC_LIBGIOUNIX_INCLUDEDIR}")
+message(STATUS "PC_LIBGIOUNIX_LIBDIR        = ${PC_LIBGIOUNIX_LIBDIR}")
+
+find_path(LIBGIOUNIX_INCLUDE_DIR
+          NAMES gio/gunixfdlist.h
+          HINTS ${PC_LIBGIOUNIX_INCLUDEDIR} ${PC_LIBGIOUNIX_INCLUDE_DIRS}
+          PATH_SUFFIXES gio-unix-2.0 )
+
+find_library(LIBGIOUNIX_LIBRARY
+             NAMES gio-2.0
+             HINTS ${PC_LIBGIOUNIX_LIBDIR} ${PC_LIBGIOUNIX_LIBRARY_DIRS} )
+
+message(STATUS "LIBGIOUNIX_INCLUDE_DIR           = ${LIBGIOUNIX_INCLUDE_DIR}")
+message(STATUS "LIBGIOUNIX_LIBRARY               = ${LIBGIOUNIX_LIBRARY}")
+
+# handle the QUIETLY and REQUIRED arguments and set component to TRUE
+# if all listed variables are TRUE
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(LibGioUnix DEFAULT_MSG
+                                  LIBGIOUNIX_LIBRARY LIBGIOUNIX_INCLUDE_DIR)
+
+mark_as_advanced(LIBGIOUNIX_INCLUDE_DIR LIBGIOUNIX_LIBRARY)
+
+set(LIBGIOUNIX_INCLUDE_DIRS ${LIBGIOUNIX_INCLUDE_DIR})
+set(LIBGIOUNIX_LIBRARIES ${LIBGIOUNIX_LIBRARY})
+
--- /dev/null
+++ b/cmake/modules/FindLibGlib.cmake
@@ -0,0 +1,72 @@
+#============================================================================
+# Copyright (c) 2017 Liberty Global
+#============================================================================
+
+# - Try to find Glib
+#
+# Once done this will define
+#  LIBGLIB_FOUND           - System has the component
+#  LIBGLIB_INCLUDE_DIRS    - Component include directories
+#  LIBGLIB_LIBRARIES       - Libraries needed to use the component
+
+# Use the pkgconfig
+find_package(PkgConfig REQUIRED)
+
+# Find the component information
+pkg_check_modules(PC_LIBGLIB QUIET glib-2.0)
+
+# <XPREFIX>_FOUND          - set to 1 if module(s) exist
+# <XPREFIX>_LIBRARIES      - only the libraries (w/o the '-l')
+# <XPREFIX>_LIBRARY_DIRS   - the paths of the libraries (w/o the '-L')
+# <XPREFIX>_LDFLAGS        - all required linker flags
+# <XPREFIX>_LDFLAGS_OTHER  - all other linker flags
+# <XPREFIX>_INCLUDE_DIRS   - the '-I' preprocessor flags (w/o the '-I')
+# <XPREFIX>_CFLAGS         - all required cflags
+# <XPREFIX>_CFLAGS_OTHER   - the other compiler flags
+
+# <XPREFIX>_VERSION    - version of the module
+# <XPREFIX>_PREFIX     - prefix-directory of the module
+# <XPREFIX>_INCLUDEDIR - include-dir of the module
+# <XPREFIX>_LIBDIR     - lib-dir of the module
+
+message(STATUS "PC_LIBGLIB_FOUND         = ${PC_LIBGLIB_FOUND}")
+message(STATUS "PC_LIBGLIB_LIBRARIES     = ${PC_LIBGLIB_LIBRARIES}")
+message(STATUS "PC_LIBGLIB_LIBRARY_DIRS  = ${PC_LIBGLIB_LIBRARY_DIRS}")
+message(STATUS "PC_LIBGLIB_LDFLAGS       = ${PC_LIBGLIB_LDFLAGS}")
+message(STATUS "PC_LIBGLIB_LDFLAGS_OTHER = ${PC_LIBGLIB_LDFLAGS_OTHER}")
+message(STATUS "PC_LIBGLIB_INCLUDE_DIRS  = ${PC_LIBGLIB_INCLUDE_DIRS}")
+message(STATUS "PC_LIBGLIB_CFLAGS        = ${PC_LIBGLIB_CFLAGS}")
+message(STATUS "PC_LIBGLIB_CFLAGS_OTHER  = ${PC_LIBGLIB_CFLAGS_OTHER}")
+message(STATUS "PC_LIBGLIB_VERSION       = ${PC_LIBGLIB_VERSION}")
+message(STATUS "PC_LIBGLIB_PREFIX        = ${PC_LIBGLIB_PREFIX}")
+message(STATUS "PC_LIBGLIB_INCLUDEDIR    = ${PC_LIBGLIB_INCLUDEDIR}")
+message(STATUS "PC_LIBGLIB_LIBDIR        = ${PC_LIBGLIB_LIBDIR}")
+
+find_path(LIBGLIB_INCLUDE_DIR
+          NAMES glib.h
+          HINTS ${PC_LIBGLIB_INCLUDEDIR} ${PC_LIBGLIB_INCLUDE_DIRS}
+          PATH_SUFFIXES glib-2.0 )
+
+find_path(LIBGLIB_CONFIG_INCLUDE_DIR
+          NAMES glibconfig.h
+          HINTS ${PC_LIBGLIB_INCLUDEDIR} ${PC_LIBGLIB_INCLUDE_DIRS}
+          PATH_SUFFIXES lib/glib-2.0/include ../lib/glib-2.0/include )
+
+find_library(LIBGLIB_LIBRARY
+             NAMES glib-2.0
+             HINTS ${PC_LIBGLIB_LIBDIR} ${PC_LIBGLIB_LIBRARY_DIRS} )
+
+message(STATUS "LIBGLIB_INCLUDE_DIR           = ${LIBGLIB_INCLUDE_DIR}")
+message(STATUS "LIBGLIB_CONFIG_INCLUDE_DIR    = ${LIBGLIB_CONFIG_INCLUDE_DIR}")
+message(STATUS "LIBGLIB_LIBRARY               = ${LIBGLIB_LIBRARY}")
+
+# handle the QUIETLY and REQUIRED arguments and set component to TRUE
+# if all listed variables are TRUE
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(LibGlib DEFAULT_MSG
+                                  LIBGLIB_LIBRARY LIBGLIB_INCLUDE_DIR LIBGLIB_CONFIG_INCLUDE_DIR)
+
+mark_as_advanced(LIBGLIB_INCLUDE_DIR LIBGLIB_CONFIG_INCLUDE_DIR LIBGLIB_LIBRARY)
+
+set(LIBGLIB_INCLUDE_DIRS ${LIBGLIB_INCLUDE_DIR} ${LIBGLIB_CONFIG_INCLUDE_DIR})
+set(LIBGLIB_LIBRARIES ${LIBGLIB_LIBRARY})
--- /dev/null
+++ b/cmake/modules/FindLibGobject.cmake
@@ -0,0 +1,67 @@
+#============================================================================
+# Copyright (c) 2017 Liberty Global
+#============================================================================
+
+# - Try to find Gobject
+#
+# Once done this will define
+#  LIBGOBJECT_FOUND           - System has the component
+#  LIBGOBJECT_INCLUDE_DIRS    - Component include directories
+#  LIBGOBJECT_LIBRARIES       - Libraries needed to use the component
+
+# Use the pkgconfig
+find_package(PkgConfig REQUIRED)
+
+# Find the component information
+pkg_check_modules(PC_LIBGOBJECT QUIET gobject-2.0)
+
+# <XPREFIX>_FOUND          - set to 1 if module(s) exist
+# <XPREFIX>_LIBRARIES      - only the libraries (w/o the '-l')
+# <XPREFIX>_LIBRARY_DIRS   - the paths of the libraries (w/o the '-L')
+# <XPREFIX>_LDFLAGS        - all required linker flags
+# <XPREFIX>_LDFLAGS_OTHER  - all other linker flags
+# <XPREFIX>_INCLUDE_DIRS   - the '-I' preprocessor flags (w/o the '-I')
+# <XPREFIX>_CFLAGS         - all required cflags
+# <XPREFIX>_CFLAGS_OTHER   - the other compiler flags
+
+# <XPREFIX>_VERSION    - version of the module
+# <XPREFIX>_PREFIX     - prefix-directory of the module
+# <XPREFIX>_INCLUDEDIR - include-dir of the module
+# <XPREFIX>_LIBDIR     - lib-dir of the module
+
+message(STATUS "PC_LIBGOBJECT_FOUND         = ${PC_LIBGOBJECT_FOUND}")
+message(STATUS "PC_LIBGOBJECT_LIBRARIES     = ${PC_LIBGOBJECT_LIBRARIES}")
+message(STATUS "PC_LIBGOBJECT_LIBRARY_DIRS  = ${PC_LIBGOBJECT_LIBRARY_DIRS}")
+message(STATUS "PC_LIBGOBJECT_LDFLAGS       = ${PC_LIBGOBJECT_LDFLAGS}")
+message(STATUS "PC_LIBGOBJECT_LDFLAGS_OTHER = ${PC_LIBGOBJECT_LDFLAGS_OTHER}")
+message(STATUS "PC_LIBGOBJECT_INCLUDE_DIRS  = ${PC_LIBGOBJECT_INCLUDE_DIRS}")
+message(STATUS "PC_LIBGOBJECT_CFLAGS        = ${PC_LIBGOBJECT_CFLAGS}")
+message(STATUS "PC_LIBGOBJECT_CFLAGS_OTHER  = ${PC_LIBGOBJECT_CFLAGS_OTHER}")
+message(STATUS "PC_LIBGOBJECT_VERSION       = ${PC_LIBGOBJECT_VERSION}")
+message(STATUS "PC_LIBGOBJECT_PREFIX        = ${PC_LIBGOBJECT_PREFIX}")
+message(STATUS "PC_LIBGOBJECT_INCLUDEDIR    = ${PC_LIBGOBJECT_INCLUDEDIR}")
+message(STATUS "PC_LIBGOBJECT_LIBDIR        = ${PC_LIBGOBJECT_LIBDIR}")
+
+find_path(LIBGOBJECT_INCLUDE_DIR
+          NAMES gobject/gobject.h
+          HINTS ${PC_LIBGOBJECT_INCLUDEDIR} ${PC_LIBGOBJECT_INCLUDE_DIRS}
+)
+
+find_library(LIBGOBJECT_LIBRARY
+             NAMES gobject-2.0
+             HINTS ${PC_LIBGOBJECT_LIBDIR} ${PC_LIBGOBJECT_LIBRARY_DIRS}
+)
+
+message(STATUS "LIBGOBJECT_INCLUDE_DIR           = ${LIBGOBJECT_INCLUDE_DIR}")
+message(STATUS "LIBGOBJECT_LIBRARY               = ${LIBGOBJECT_LIBRARY}")
+
+# handle the QUIETLY and REQUIRED arguments and set component to TRUE
+# if all listed variables are TRUE
+include(FindPackageHandleStandardArgs)
+find_package_handle_standard_args(LibGobject DEFAULT_MSG
+                                  LIBGOBJECT_LIBRARY LIBGOBJECT_INCLUDE_DIR)
+
+mark_as_advanced(LIBGOBJECT_INCLUDE_DIR LIBGOBJECT_LIBRARY)
+
+set(LIBGOBJECT_INCLUDE_DIRS ${LIBGOBJECT_INCLUDE_DIR})
+set(LIBGOBJECT_LIBRARIES ${LIBGOBJECT_LIBRARY})
