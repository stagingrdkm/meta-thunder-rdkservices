From 7be35eae2f3e4919509455563cfbd2b1b9eb4cdc Mon Sep 17 00:00:00 2001
From: Pierre Wielders <pierre@wielders.net>
Date: Fri, 15 Oct 2021 10:32:12 +0200
Subject: [PATCH] [JSON] Automatically escape UTF8 in JSON. (#770)

* [JSON] Automatically escape UTF8 in JSON.

* [WARNING] Warning free build on linux.

* [JSON] UTF16 pairs should always start with 0xD8XX otherwise it is a UTF16 keypoint.

* JSON: return error on enum check failure

* JSON: Tester: FromString: check the error state for the status

* JSON: Clear object, if there is an error during the parsing (#774)

Co-authored-by: HaseenaSainul <41037131+HaseenaSainul@users.noreply.github.com>
Co-authored-by: Haseena Sainul <h.sainul@metrological.com>
---
 Source/core/JSON.cpp          |   4 +-
 Source/core/JSON.h            | 720 ++++++++++++++++++++--------------
 Source/core/Serialization.cpp | 108 +++++
 Source/core/Serialization.h   |  14 +
 4 files changed, 548 insertions(+), 298 deletions(-)

diff --git a/Source/core/JSON.cpp b/Source/core/JSON.cpp
index fc922e9c..c49f3858 100644
--- a/Source/core/JSON.cpp
+++ b/Source/core/JSON.cpp
@@ -38,7 +38,9 @@ namespace Core {
 
         /* static */ constexpr size_t Error::kContextMaxLength;
 
-        /* static */ char IElement::NullTag[] = "null";
+        /* static */ char IElement::NullTag[5] = { 'n', 'u', 'l', 'l', '\0' };
+        /* static */ char IElement::TrueTag[5] = { 't', 'r', 'u', 'e', '\0' };
+        /* static */ char IElement::FalseTag[6] = { 'f', 'a', 'l', 's', 'e', '\0' };
 
         string Variant::GetDebugString(const TCHAR name[], int indent, int arrayIndex) const
         {
diff --git a/Source/core/JSON.h b/Source/core/JSON.h
index 37ba7cd0..7658b8a0 100644
--- a/Source/core/JSON.h
+++ b/Source/core/JSON.h
@@ -85,7 +85,9 @@ namespace Core {
 
         struct EXTERNAL IElement {
 
-            static char NullTag[];
+            static TCHAR NullTag[5];
+            static TCHAR TrueTag[5];
+            static TCHAR FalseTag[6];
 
             virtual ~IElement() {}
 
@@ -145,13 +147,14 @@ namespace Core {
                     handled += loaded;
                 }
 
-                if ((offset != 0 || handled < size) && error.IsSet() == false) {
+                if (((offset != 0) || (handled < size)) && (error.IsSet() == false)) {
                     error = Error{ "Malformed JSON. Missing closing quotes or brackets" };
                     realObject.Clear();
                 }
 
                 if (error.IsSet() == true) {
                     TRACE_L1("Parsing failed: %s", ErrorDisplayMessage(error.Value()).c_str());
+                    realObject.Clear();
                 }
 
                 return (error.IsSet() == false);
@@ -538,15 +541,15 @@ namespace Core {
             void Null(const bool enabled)
             {
                 if (enabled == true)
-                    _set |= UNDEFINED;
+                    _set |= (SET | UNDEFINED);
                 else
-                    _set &= ~UNDEFINED;
+                    _set &= ~(SET | UNDEFINED);
             }
 
             // IElement and IMessagePack iface:
             bool IsSet() const override
             {
-                return ((_set & (SET | UNDEFINED)) != 0);
+                return ((_set & SET) != 0);
             }
 
             bool IsNull() const override
@@ -630,13 +633,12 @@ namespace Core {
             {
                 uint16_t loaded = 0;
 
-                if (offset == 0) {
-                    // We are starting, see what the current char is
-                    _value = 0;
-                    _set = 0;
-                }
+                // Peamble investigation, determine the right flags..
                 while ((offset < 4) && (loaded < maxLength)) {
                     if (offset == 0) {
+                        _value = 0;
+                        _set = 0;
+
                         if (stream[loaded] == '\"') {
                             _set = QUOTED;
                             offset++;
@@ -722,7 +724,7 @@ namespace Core {
                     loaded++;
                 }
 
-                bool completed = ((_set & ERROR) != 0);
+                bool completed = ((_set & (ERROR|UNDEFINED)) != 0);
 
                 while ((loaded < maxLength) && (completed == false)) {
                     if (isdigit(stream[loaded])) {
@@ -753,7 +755,7 @@ namespace Core {
                             offset = 0;
                         }
                     }
-                } else if (completed == true) {
+                } else if ( (completed == true) && (offset >= 4) ) {
                     if (_set & NEGATIVE) {
                         _value *= -1;
                     }
@@ -1044,15 +1046,15 @@ namespace Core {
             void Null(const bool enabled)
             {
                 if (enabled == true)
-                    _set |= UNDEFINED;
+                    _set |= (UNDEFINED|SET);
                 else
-                    _set &= ~UNDEFINED;
+                    _set &= ~(UNDEFINED|SET);
             }
 
             // IElement and IMessagePack iface:
             bool IsSet() const override
             {
-                return ((_set & (SET | UNDEFINED)) != 0);
+                return ((_set & SET) != 0);
             }
 
             bool IsNull() const override
@@ -1102,13 +1104,10 @@ namespace Core {
                     std::isinf(_value) ||
                     std::isnan(_value)) 
                 {
-                    auto len = strlen(IElement::NullTag);
-                    ASSERT (offset < len);
-                    while(loaded < (len - offset))
-                    {
-                        stream[loaded] = IElement::NullTag[offset + loaded];
-                        loaded++;
-                    }
+                    ASSERT(offset < (sizeof(IElement::NullTag) - 1));
+                    loaded = std::min(static_cast<uint16_t>((sizeof(IElement::NullTag) - 1) - offset), maxLength);
+                    ::memcpy(stream, &(IElement::NullTag[offset]), loaded);
+                    offset = (((offset + loaded) == (sizeof(IElement::NullTag) - 1)) ? 0 : offset + loaded);
                 }
                 else
                 {
@@ -1143,9 +1142,8 @@ namespace Core {
                         loaded++;
                         offset++;
                         _set &= ~QUOTED;
-                    } else if (((_set & QUOTED) == 0) && (::isspace(stream[loaded]) || (stream[loaded] == '\0') ||
-                               (stream[loaded] == ',') || (stream[loaded] == '}') || (stream[loaded] == ']') ||
-                               (stream[loaded] == ')'))) {
+                    } else if ( (((_set & QUOTED) == 0) && (::isspace(stream[loaded]))) || (stream[loaded] == '\0') ||
+                               (stream[loaded] == ',') || (stream[loaded] == '}') || (stream[loaded] == ']') ) {
                         completed = true;
                     } else {
                         _strValue += stream[loaded++];
@@ -1156,7 +1154,7 @@ namespace Core {
                 if (completed == true) {
 
                     if (_strValue == IElement::NullTag) {
-                        _set |= UNDEFINED;
+                        _set |= (SET|UNDEFINED);
 
                     } else {
                         TYPE val;
@@ -1175,9 +1173,9 @@ namespace Core {
                             _set |= SET;
                         }
 
-                        offset = 0;
-                        _strValue.Clear();
+                        _strValue.clear();
                     }
+                    offset = 0;
                 }
 
                 return loaded;
@@ -1329,15 +1327,15 @@ namespace Core {
             void Null(const bool enabled)
             {
                 if (enabled == true)
-                    _value |= NullBit;
+                    _value |= (SetBit|NullBit);
                 else
-                    _value &= ~NullBit;
+                    _value &= ~(SetBit|NullBit);
             }
 
             // IElement and IMessagePack iface:
             bool IsSet() const override
             {
-                return ((_value & (SetBit | NullBit)) != 0);
+                return ((_value & SetBit) != 0);
             }
 
             bool IsNull() const override
@@ -1398,7 +1396,7 @@ namespace Core {
                         _value = (_value & DefaultBit);
                         offset = 1;
                         loaded = 1;
-                    } else if (stream[0] == 'n') {
+                    } else if (stream[0] == IElement::NullTag[0]) {
                         offset = 1;
                         _value = NullBit | (_value & DefaultBit);
                         loaded = 1;
@@ -1415,7 +1413,7 @@ namespace Core {
                 }
 
                 if (offset > 0) {
-                    uint8_t length = (_value & NullBit ? 4 : _value & DeserializeBit ? sizeof(trueBuffer) : sizeof(falseBuffer)) - 1;
+                    uint8_t length = (_value & NullBit ? sizeof(IElement::NullTag) : _value & DeserializeBit ? sizeof(trueBuffer) : sizeof(falseBuffer)) - 1;
                     const char* buffer = (_value & NullBit ? IElement::NullTag : _value & DeserializeBit ? trueBuffer : falseBuffer);
 
                     while ((loaded < maxLength) && (offset < length) && ((_value & ErrorBit) == 0)) {
@@ -1473,46 +1471,42 @@ namespace Core {
 
         class EXTERNAL String : public IElement, public IMessagePack {
         private:
-            static constexpr uint32_t None = 0x00000000;
-            static constexpr uint32_t ScopeMask = 0x007FFFFF;
-            static constexpr uint32_t DepthCountMask = 0x0F800000;
-            static constexpr uint32_t QuotedSerializeBit = 0x80000000;
-            static constexpr uint32_t SetBit = 0x40000000;
-            static constexpr uint32_t QuoteFoundBit = 0x20000000;
-            static constexpr uint32_t NullBit = 0x10000000;
-
-            template <int N>
-            uint8_t MaxOpaqueObjectDepth()
-            {
-                return ((N >> 1) > 0) ? 1 + MaxOpaqueObjectDepth<(N >> 1)>() : 1;
-            }
-            const std::map<uint8_t, uint8_t> EscapeKeyLookupTable = {
-                {'b',0x08}, {'f', 0x0c}, {'n', 0x0a}, {'r', 0x0d}, {'t', 0x09}, {'/', '/'}
+            static constexpr uint16_t FlagMask = 0xFC00;
+            static constexpr uint16_t EscapeFoundBit = 0x0400;
+            static constexpr uint16_t SpecialSequenceBit = 0x0800;
+            static constexpr uint16_t QuotedSerializeBit = 0x1000;
+            static constexpr uint16_t QuoteFoundBit = 0x2000;
+            static constexpr uint16_t NullBit = 0x4000;
+            static constexpr uint16_t SetBit = 0x8000;
+
+            enum class ScopeBracket : uint8_t {
+                CURLY_BRACKET = 0,
+                SQUARE_BRACKET = 1
             };
 
         public:
             explicit String(const bool quoted = true)
                 : _default()
-                , _scopeCount(quoted ? QuotedSerializeBit : None)
-                , _unaccountedCount(0)
                 , _value()
+                , _storage(0)
+                , _flagsAndCounters(quoted ? QuotedSerializeBit : 0)
             {
             }
 
             explicit String(const string& Value, const bool quoted = true)
                 : _default()
-                , _scopeCount(quoted ? QuotedSerializeBit : None)
-                , _unaccountedCount(0)
                 , _value()
+                , _storage(0)
+                , _flagsAndCounters(quoted ? QuotedSerializeBit : 0)
             {
                 Core::ToString(Value.c_str(), _default);
             }
 
             explicit String(const char Value[], const bool quoted = true)
                 : _default()
-                , _scopeCount(quoted ? QuotedSerializeBit : None)
-                , _unaccountedCount(0)
                 , _value()
+                , _storage(0)
+                , _flagsAndCounters(quoted ? QuotedSerializeBit : 0)
             {
                 Core::ToString(Value, _default);
             }
@@ -1520,9 +1514,9 @@ namespace Core {
 #ifndef __NO_WCHAR_SUPPORT__
             explicit String(const wchar_t Value[], const bool quoted = true)
                 : _default()
-                , _scopeCount(quoted ? QuotedSerializeBit : None)
-                , _unaccountedCount(0)
                 , _value()
+                , _storage(0)
+                , _flagsAndCounters(quoted ? QuotedSerializeBit : 0)
             {
                 Core::ToString(Value, _default);
             }
@@ -1530,20 +1524,18 @@ namespace Core {
 
             String(const String& copy)
                 : _default(copy._default)
-                , _scopeCount(copy._scopeCount)
-                , _unaccountedCount(copy._unaccountedCount)
                 , _value(copy._value)
+                , _storage(copy._storage)
+                , _flagsAndCounters(copy._flagsAndCounters)
             {
             }
 
-            ~String() override
-            {
-            }
+            ~String() override = default;
 
             String& operator=(const string& RHS)
             {
                 Core::ToString(RHS.c_str(), _value);
-                _scopeCount |= SetBit;
+                _flagsAndCounters |= SetBit;
 
                 return (*this);
             }
@@ -1551,7 +1543,7 @@ namespace Core {
             String& operator=(const char RHS[])
             {
                 Core::ToString(RHS, _value);
-                _scopeCount |= SetBit;
+                _flagsAndCounters |= SetBit;
 
                 return (*this);
             }
@@ -1560,7 +1552,7 @@ namespace Core {
             String& operator=(const wchar_t RHS[])
             {
                 Core::ToString(RHS, _value);
-                _scopeCount |= SetBit;
+                _flagsAndCounters |= SetBit;
 
                 return (*this);
             }
@@ -1570,8 +1562,7 @@ namespace Core {
             {
                 _default = RHS._default;
                 _value = RHS._value;
-                _scopeCount = RHS._scopeCount;
-                _unaccountedCount = RHS._unaccountedCount;
+                _flagsAndCounters = RHS._flagsAndCounters;
 
                 return (*this);
             }
@@ -1632,10 +1623,10 @@ namespace Core {
 
             inline const string Value() const
             {
-                if ((_scopeCount & (SetBit | QuoteFoundBit | QuotedSerializeBit)) == (SetBit | QuoteFoundBit)) {
+                if ((_flagsAndCounters & (SetBit | QuoteFoundBit | QuotedSerializeBit)) == (SetBit | QuoteFoundBit)) {
                     return ('\"' + Core::ToString(_value.c_str()) + '\"');
                 }
-                return (((_scopeCount & (SetBit | NullBit)) == SetBit) ? Core::ToString(_value.c_str()) : Core::ToString(_default.c_str()));
+                return (((_flagsAndCounters & (SetBit | NullBit)) == SetBit) ? Core::ToString(_value.c_str()) : Core::ToString(_default.c_str()));
             }
 
             inline const string& Default() const
@@ -1645,109 +1636,204 @@ namespace Core {
 
             void Null(const bool enabled)
             {
-                if (enabled == true)
-                    _scopeCount |= NullBit;
-                else
-                    _scopeCount &= ~NullBit;
+                if (enabled == true) {
+                    _flagsAndCounters |= (NullBit | SetBit);
+                    _value = IElement::NullTag;
+                }
+                else {
+                    _flagsAndCounters &= ~(NullBit | SetBit);
+                    _value.clear();
+                }
             }
 
             // IElement iface:
             bool IsNull() const override
             {
-                return (_scopeCount & NullBit) != 0;
+                return (_flagsAndCounters & NullBit) != 0;
             }
 
             bool IsSet() const override
             {
-                return ((_scopeCount & (SetBit | NullBit)) != 0);
+                return ((_flagsAndCounters & SetBit) != 0);
             }
 
             void Clear() override
             {
-                _scopeCount = (_scopeCount & QuotedSerializeBit);
+                _flagsAndCounters = (_flagsAndCounters & QuotedSerializeBit);
+                _value.clear();
             }
 
             inline bool IsQuoted() const
             {
-                return ((_scopeCount & (QuotedSerializeBit | QuoteFoundBit)) != 0);
+                return (((_flagsAndCounters & NullBit) == 0) && ((_flagsAndCounters & (QuotedSerializeBit | QuoteFoundBit)) != 0));
             }
 
             inline void SetQuoted(const bool enable)
             {
                 if (enable == true) {
-                    _scopeCount |= QuotedSerializeBit;
-                } else {
-                    _scopeCount &= (~QuotedSerializeBit);
+                    _flagsAndCounters |= QuotedSerializeBit;
+                }
+                else {
+                    _flagsAndCounters &= (~QuotedSerializeBit);
                 }
             }
 
         protected:
-            inline bool MatchLastCharacter(const string& str, char ch) const
-            {
-                return (str.length() > 0) && (str[str.length() - 1] == ch);
-            }
-
             // IElement iface:
             uint16_t Serialize(char stream[], const uint16_t maxLength, uint32_t& offset) const override
             {
-                bool quoted = IsQuoted();
                 uint16_t result = 0;
 
                 ASSERT(maxLength > 0);
 
-                if ((quoted == false) || ((_scopeCount & NullBit) != 0)) {
-                    std::string source((_value.empty() || (_scopeCount & NullBit)) ? NullTag : _value);
-                    result = static_cast<uint16_t>(source.copy(stream, maxLength, offset));
-                    offset = (result < maxLength ? 0 : offset + result);
-                } else {
-                    if (offset == 0) {
-                        // We always start with a quote or Block marker
-                        stream[result++] = '\"';
+                if ((_flagsAndCounters & SetBit) != 0) {
+                    bool isQuoted = IsQuoted();
+                    if (offset == 0)  {
+                        if (isQuoted == true) {
+                            // We always start with a quote or Block marker
+                            stream[result++] = '\"';
+                        }
                         offset = 1;
-                        _unaccountedCount = 0;
+                        _flagsAndCounters &= (FlagMask ^ (SpecialSequenceBit|EscapeFoundBit));
                     }
 
                     uint32_t length = static_cast<uint32_t>(_value.length()) - (offset - 1);
-                    if (length > 0) {
-                        const TCHAR* source = &(_value[offset - 1]);
-                        offset += length;
 
-                        while ((result < maxLength) && (length > 0)) {
+                    while ((result < maxLength) && (length > 0)) {
+                        const uint16_t current = static_cast<uint16_t>((_value[offset - 1]) & 0xFF);
+                           
+                        // See if this is a printable character
+                        if ((isQuoted == false) || ((::isprint(current)) && (current != '\"') && (current != '\\') && (current != '/')) ) {
+                            stream[result++] = static_cast<TCHAR>(current);
+                            length--;
+                            offset++;
+                        }
+                        else if ((_flagsAndCounters & SpecialSequenceBit) == 0) {
+                            // We need to escape these..
+                            stream[result++] = '\\';
+                            _flagsAndCounters |= SpecialSequenceBit;
+                        }
+                        else if ((_flagsAndCounters & 0xFF) == 0x00) {
+                            // Check if it is a single character drop or a \u
+                            switch (current) {
+                            case 0x08: stream[result++] = 'b'; break;
+                            case 0x09: stream[result++] = 't'; break;
+                            case 0x0a: stream[result++] = 'n'; break;
+                            case 0x0c: stream[result++] = 'f'; break;
+                            case 0x0d: stream[result++] = 'r'; break;
+                            case '\\': stream[result++] = '\\'; break;
+                            case '/': stream[result++] = '/'; break;
+                            case '"': stream[result++] = '"'; break;
+                            default: {
+                                uint16_t lowPart, highPart;
+                                int8_t codeSize = ToCodePoint(&(_value[offset - 1]), length, _storage);
+
+                                if (codeSize < 0) {
+                                    // Oops it is a bad code thingy, Skip it..
+                                    // TODO: report an error
+                                    codeSize = -codeSize;
+                                }
 
-                            // See where we are and add...
-                            if (((*source == '\"') || (*source == '\\')) && (_unaccountedCount == 0)) {
-                                stream[result++] = '\\';
-                                _unaccountedCount = 1;
-                            }
-                            
-                            if (result < maxLength) {
+                                ASSERT(codeSize <= 7);
 
-                                char convertedValue;
-                                if ((result+1 < maxLength) && (IsEscapeSequenceValue(*source, convertedValue))) {
-                                    stream[result++] = '\\';
-                                    stream[result++] = convertedValue;
-                                } else {
-                                    stream[result++] = *source;
+                                if (CodePointToUTF16(_storage, lowPart, highPart) == false) {
+                                    // Oops we have a bad transaltion of the code point
+                                    // TODO: report an error
                                 }
 
-                                _unaccountedCount = 0;
-                                source++;
+                                _storage = (highPart << 16) | lowPart;
+
+                                // Oke start processing an escape squence and remember how many bytes we jump if
+                                // we are completed, start at 2 index now as we already wrote /u 
+                                _flagsAndCounters |= ((codeSize & 0x07) << 3) | 0x02;
+
+                                stream[result++] = 'u';
+                                break;
+                            }
+                            }
+
+                            // If all has been writeen it is time to move back to the "copying situation...
+                            if ((_flagsAndCounters & 0xFF) == 0x00) {
+                                _flagsAndCounters ^= SpecialSequenceBit;
                                 length--;
+                                offset++;
+                            }
+                        }
+                        else {
+                            if ((_flagsAndCounters & 0x7) < 0x2) {
+                                stream[result++] = ((_flagsAndCounters & 0x07) == 0 ? '\\' : 'u');
+                            }
+                            else {
+                                uint8_t part;
+
+                                // Write out the CodePoint....
+                                if (_storage > 0xFFFF) {
+                                    // First write the Most Significant part
+                                    part = (_storage >> (16 + ((5 - (_flagsAndCounters & 0x07)) * 4))) & 0x0F;
+                                }
+                                else {
+                                    part = (_storage >> ((5 - (_flagsAndCounters & 0x07)) * 4)) & 0x0F;
+                                }
+                                stream[result++] = (part > 9 ? 'A' + (part - 10) : '0' + part);
+                            }
+
+                            _flagsAndCounters += 1;
+
+                            if ((_flagsAndCounters & 0x7) == 6) {
+                                // Oke we flushed a HEX value of 4 digits, lets determine the next step..
+                                if (_storage > 0xFFFF) {
+                                    _storage = (_storage & 0xFFFF);
+                                    _flagsAndCounters &= (FlagMask | 0xF8);
+                                }
+                                else {
+                                    // We are done ! Move on, strange character has been handled and converted
+                                    uint8_t skip = ((_flagsAndCounters >> 3) & 0x07);
+                                    length -= skip;
+                                    offset += skip;
+
+                                    _flagsAndCounters &= (FlagMask ^ SpecialSequenceBit);
+                                }
                             }
                         }
                     }
 
-                    if (result == maxLength) {
-                        offset -= length;
-                    } else {
+                    if (length == 0) {
                         // And we close with a quote..
-                        stream[result++] = '\"';
-                        offset = 0;
+                        if (isQuoted == false) {
+                            offset = 0;
+                        }
+                        else if (result < maxLength) {
+                            stream[result++] = '\"';
+                            offset = 0;
+                        }
                     }
                 }
 
                 return (result);
             }
+            bool InScope(const ScopeBracket mode) {
+                bool added = false;
+                uint8_t depth = (_flagsAndCounters & 0x1F);
+
+                if ( ((depth != 0) || (_value.empty() == true)) && ((depth + 1) <= 31) ) {
+                    _storage <<= 1;
+                    _storage |= static_cast<uint8_t>(mode);
+                    _flagsAndCounters++;
+                    added = true;
+                }
+                return (added);
+            }
+            bool OutScope(const ScopeBracket mode) {
+                bool succcesfull = false;
+                ScopeBracket bracket = static_cast<ScopeBracket>(_storage & 0x1);
+                uint8_t depth = (_flagsAndCounters & 0x1F);
+                if ((depth > 0) && (bracket == mode)) {
+                    _storage >>= 1;
+                    _flagsAndCounters--;
+                    succcesfull = true;
+                }
+                return (succcesfull);
+            }
 
             uint16_t Deserialize(const char stream[], const uint16_t maxLength, uint32_t& offset, Core::OptionalType<Error>& error) override
             {
@@ -1757,119 +1843,145 @@ namespace Core {
 
                 if (offset == 0) {
                     _value.clear();
-                    if (stream[result] != '\"') {
-                        _unaccountedCount = 0;
-                    } else {
+                    _flagsAndCounters &= (FlagMask ^ (SpecialSequenceBit|EscapeFoundBit|QuoteFoundBit));
+                    _storage = 0;
+                    if (stream[result] == '\"') {
                         result++;
-                        _scopeCount |= QuoteFoundBit;
-                        _unaccountedCount = 1;
+                        _flagsAndCounters |= QuoteFoundBit;
                     }
+                    offset = 1;
                 }
 
-                bool escapedSequence = MatchLastCharacter(_value, '\\');
-
                 // Might be that the last character we added was a
                 while ((result < maxLength) && (finished == false)) {
 
                     TCHAR current = stream[result];
 
-                    if (escapedSequence == false) {
-                        // Do not interpret anything if it's quoted.
-                        if ((_scopeCount & QuoteFoundBit) != 0) {
-                            if (current == '\"') {
-                                uint8_t depth = static_cast<uint8_t>((_scopeCount & DepthCountMask) >> MaxOpaqueObjectDepth<ScopeMask>());
-                                if (depth == 0) {
-                                    result++;
-                                    finished = true;
-                                } else {
-                                    _scopeCount = ((_scopeCount ^ QuoteFoundBit) & ~DepthCountMask) | ((depth - 1) << MaxOpaqueObjectDepth<ScopeMask>());
-                                }                                
+                    // What are we deserializing a string, or an opaque JSON object!!!
+                    if ((_flagsAndCounters & QuoteFoundBit) == 0) {
+                        // It's an opaque structure, so *no* decoding required. Leave as is !
+                        if (current == '{') {
+                            if (InScope(ScopeBracket::CURLY_BRACKET) == false) {
+                                error = Error{ "Opaque object nesting too deep" };
                             }
-                        } else if (current == '\"') {
-                            _scopeCount = ((_scopeCount ^ QuoteFoundBit) & (~DepthCountMask)) | (((_scopeCount & DepthCountMask) + (1 << MaxOpaqueObjectDepth<ScopeMask>())) & DepthCountMask);
-                        } 
-                        else {
-                            uint8_t depth = ((_scopeCount & DepthCountMask) >> MaxOpaqueObjectDepth<ScopeMask>());
-                            if ((current == '{') || (current == '[')) {
-                                if (depth + 1 > MaxOpaqueObjectDepth<ScopeMask>()) {
-                                    error = Error{ "Opaque object nesting too deep" };
-                                    finished = true;
-                                } else {
-                                    ++depth;
-                                    uint32_t scope = _scopeCount & ScopeMask;
-                                    scope <<= 1;
-                                    scope |= static_cast<uint32_t>(current == '{' ? ScopeBracket::CURLY_BRACKET : ScopeBracket::SQUARE_BRACKET);
-                                    _scopeCount &= ~(DepthCountMask | ScopeMask);
-                                    _scopeCount |= (depth << MaxOpaqueObjectDepth<ScopeMask>()) | scope;
-                                }
-                            } else if ((current == '}') || (current == ']')) {
-                                if (depth > 0) {
-                                    uint32_t scope = _scopeCount & ScopeMask;
-                                    ScopeBracket bracket = static_cast<ScopeBracket>(scope & 0x1);
-                                    if ((current == '}') && (bracket != ScopeBracket::CURLY_BRACKET)) {
-                                        error = Error{ "Expected \"]\" but got \"}\" in opaque object" };
-                                        finished = true;
-                                    } else if ((current == ']') && (bracket != ScopeBracket::SQUARE_BRACKET)) {
-                                        error = Error{ "Expected \"}\" but got \"]\" in opaque object" };
-                                        finished = true;
-                                    } else {
-                                        --depth;
-                                        scope >>= 1;
-                                        _scopeCount &= ~(DepthCountMask | ScopeMask);
-                                        _scopeCount |= (depth << MaxOpaqueObjectDepth<ScopeMask>()) | scope;
-                                    }
-                                } else {
-                                    finished = true;
-                                }
-                            } else if (depth == 0) {
-                                finished = ((current == ',') || (current == ' ') || (current == '\t') || (current == '\0'));
+                        }
+                        else if (current == '[') {
+                            if (InScope(ScopeBracket::SQUARE_BRACKET) == false) {
+                                error = Error{ "Opaque object nesting too deep" };
+                            }
+                        }
+                        else if ((_flagsAndCounters & 0x1F) == 0) {
+                            // If we did not open an object, the only thing we allow are whitespaces as they can 
+                            // always be dropped!
+                            finished = (((_flagsAndCounters & EscapeFoundBit) == 0) && ((current == ',') || (current == '}') || (current == ']')));
+                        }
+                        else if (current == '}') {
+                            if (OutScope(ScopeBracket::CURLY_BRACKET) == false) {
+                                error = Error{ "Expected \"]\" but got \"}\" in opaque object" };
+                            }
+                        }
+                        else if (current == ']') {
+                            if (OutScope(ScopeBracket::SQUARE_BRACKET) == false) {
+                                error = Error{ "Expected \"}\" but got \"]\" in opaque object" };
                             }
                         }
-                    }
 
-                    if (finished == false) {
-                        EscapeSequenceAction escapeHandling = EscapeSequenceAction::NOTHING;
+                        if (finished == false) {
+                            // Write the amount we possibly can..
+                            _value += current;
+
+                            if ((current == '\"') && ((_value.empty() == true) || (_value[_value.length() - 1] != '\\'))) {
+                                // Oke we are going to enetr a Serialized thingy... lets be opaque from here on
+                                _flagsAndCounters ^= EscapeFoundBit;
+                            }
+
+                            result++;
+                        }
+                    }
+                    // Since it is a "real" string translate back all escaped stuff.. are we in an unescaping mode?
+                    else if ((_flagsAndCounters & SpecialSequenceBit) == 0x00) {
+                        // Nope we are not, so see if we need to start it and otherwise, just copy...
+                        if (current == '\\') {
+                            // And we need to start it.
+                            _flagsAndCounters |= SpecialSequenceBit;
+                        }
+                        else if (current == '\"') {
+                            // We are done! leave this element.
+                            finished = true;
+                        }
+                        else {
+                            // Just copy, we and onto the next;
+                            _value += current;
+                        }
+                        result++;
+                    }
+                    else if ((_flagsAndCounters & 0xFF) == 0x00) {
 
-                        if ((escapedSequence == true) && ((_scopeCount & DepthCountMask) == 0)) {
-                            if ((current == '\\') && (_value[_value.length() - 1] == '\\')) {
-                                escapeHandling = EscapeSequenceAction::COLLAPSE;
-                            } else if (!IsValidEscapeSequence(current)) {
-                                finished = true;
-                                error = Error{ "Invalid escape sequence \"\\" + std::string(1, current) + "\"." };
-                                ++result;
+                        if (current == 'u') {
+                            _flagsAndCounters |= 0x4;
+                        }
+                        else {
+                            // We are in a string mode, so we need to decode. Decode what we receive..
+                            switch (current) {
+                            case '\"': _value += '\"'; break;
+                            case '\\': _value += '\\'; break;
+                            case '/':  _value += '/';  break;
+                            case 'b':  _value += static_cast<TCHAR>(0x08); break;
+                            case 't':  _value += static_cast<TCHAR>(0x09); break;
+                            case 'n':  _value += static_cast<TCHAR>(0x0a); break;
+                            case 'f':  _value += static_cast<TCHAR>(0x0c); break;
+                            case 'r':  _value += static_cast<TCHAR>(0x0d); break;
+                            default:
+                                error = Error{ "unknown escaping code." };
                                 break;
-                            } else {
-                                escapeHandling = GetEscapeSequenceAction(current);
                             }
+                            _flagsAndCounters ^= SpecialSequenceBit;
                         }
+                        result++;
+                    }
+                    else {
+                        // If we end up here, we are actually gathering unicode values to be decoded.
+                        _flagsAndCounters--;
 
-                        escapedSequence = ((escapedSequence == 0) && (current == '\\') && (escapeHandling != EscapeSequenceAction::COLLAPSE));
-                        if (escapeHandling == EscapeSequenceAction::COLLAPSE) {
-                            _value[_value.length() - 1] = current;
-                            ++_unaccountedCount;
-                        } else if (escapeHandling == EscapeSequenceAction::REPLACE) {
-                            _value[_value.length() - 1] = GetEscapeSequenceValue(current);
-                        } else {
-                            // Write the amount we possibly can..
-                            _value += current;
+                        if (::isxdigit(current) == false) {
+                            error = Error{ "the unescaping of the u requires hexadecimal characters" };
                         }
+                        else {
+                            _storage = (_storage << 4) | ((::isdigit(current) ? current - '0' : 10 + (::toupper(current) - 'A')) & 0xF);
+                            result++;
+                            if ((_flagsAndCounters & 0xFF) == 0x00) {
+                                _flagsAndCounters ^= SpecialSequenceBit;
 
+                                // Examine the codePoint, if ot is a pair ot not..
+                                if ( (_storage >= 0xFFFF) || ((_storage & 0xFC00) != 0xD800) ) {
 
-                        // Move on to the next position
-                        result++;
+                                    // We have a full monty, 2 x UTF16 to be translated :-)
+                                    uint32_t codePoint;
+                                    TCHAR buffer[6];
+
+                                    UTF16ToCodePoint((_storage & 0xFFFF), ((_storage >> 16) & 0xFFFF), codePoint);
+
+                                    // Seems like we have a pending code point to be added, before we add anaything elese :-)
+                                    int8_t bytes = FromCodePoint(codePoint, buffer, sizeof(buffer));
+
+                                    if (bytes <= 0) {
+                                        error = Error{ "There is no valid codepoint defined." };
+                                    }
+                                    else {
+                                        _value += string(buffer, bytes);
+                                    }
+                                    _storage = 0;
+                                }
+                            }
+                        }
                     }
                 }
 
-                if (finished == false) {
-                    offset = static_cast<uint32_t>(_value.length()) + _unaccountedCount;
+                if ( (finished == false) && (error.IsSet() == false) ) {
+                    offset += static_cast<uint32_t>(_value.length()) ;
                 } else {
                     offset = 0;
-                    _scopeCount |= ((_scopeCount & QuoteFoundBit) ? SetBit : (_value == NullTag ? NullBit : SetBit));
-                    if ((_scopeCount & QuoteFoundBit) == 0) {
-                         // Right-trim the non-string value, it's always left-trimmed already
-                        _value.erase(std::find_if(_value.rbegin(), _value.rend(), [](const unsigned char ch) { return (!std::isspace(ch)); }).base
-(), _value.end());
-                    }
+                    _flagsAndCounters |= (_value == IElement::NullTag ? NullBit|SetBit : SetBit);
                 }
 
                 return (result);
@@ -1880,18 +1992,18 @@ namespace Core {
             {
                 uint16_t loaded = 0;
                 if (offset == 0) {
-                    if ((_scopeCount & NullBit) != 0) {
+                    if ((_flagsAndCounters & NullBit) != 0) {
                         stream[loaded++] = IMessagePack::NullValue;
                     } else if (_value.length() <= 31) {
-                        _unaccountedCount = 1;
+                        _storage = 1;
                         stream[loaded++] = static_cast<uint8_t>(_value.length() | 0xA0);
                         offset++;
                     } else if (_value.length() <= 0xFF) {
-                        _unaccountedCount = 2;
+                        _storage = 2;
                         stream[loaded++] = 0xD9;
                         offset++;
                     } else if (_value.length() <= 0xFFFF) {
-                        _unaccountedCount = 3;
+                        _storage = 3;
                         stream[loaded++] = 0xDA;
                         offset++;
                     } else {
@@ -1900,19 +2012,19 @@ namespace Core {
                 }
 
                 if (offset != 0) {
-                    while ((loaded < maxLength) && (offset < _unaccountedCount)) {
-                        stream[loaded++] = static_cast<uint8_t>((_value.length() >> (8 * (_unaccountedCount - offset - 1))) & 0xFF);
+                    while ((loaded < maxLength) && (offset < (_storage & 0x0F))) {
+                        stream[loaded++] = static_cast<uint8_t>((_value.length() >> (8 * ( (_storage & 0x0F) - offset - 1))) & 0xFF);
                         offset++;
                     }
 
                     uint16_t copied = 0;
                     while ((loaded < maxLength) && (offset != 0)) {
-                        copied = static_cast<uint16_t>(_value.copy(reinterpret_cast<char*>(&stream[loaded]), (maxLength - loaded), offset - _unaccountedCount));
+                        copied = static_cast<uint16_t>(_value.copy(reinterpret_cast<char*>(&stream[loaded]), (maxLength - loaded), offset - (_storage & 0x0F)));
                         offset += copied;
                         loaded += copied;
-                        if (_unaccountedCount) {
-                           offset -=_unaccountedCount;
-                           _unaccountedCount = 0;
+                        if ((_storage & 0x0F) != 0) {
+                           offset -= (_storage & 0x0F);
+                           _storage = 0;
                         }
 
                         if (offset >= _value.length()) {
@@ -1930,18 +2042,18 @@ namespace Core {
                 if (offset == 0) {
                     _value.clear();
                     if (stream[loaded] == IMessagePack::NullValue) {
-                        _scopeCount |= NullBit;
+                        _flagsAndCounters |= NullBit;
                         loaded++;
                     } else if ((stream[loaded] & 0xA0) == 0xA0) {
-                        _unaccountedCount = stream[loaded] & 0x1F;
+                        _storage = stream[loaded] & 0x1F;
                         offset = 3;
                         loaded++;
                     } else if (stream[loaded] == 0xD9) {
-                        _unaccountedCount = 0;
+                        _storage = 0;
                         offset = 2;
                         loaded++;
                     } else if (stream[loaded] == 0xDA) {
-                        _unaccountedCount = 0;
+                        _storage = 0;
                         offset = 1;
                         loaded++;
                     } else {
@@ -1951,18 +2063,18 @@ namespace Core {
 
                 if (offset != 0) {
                     while ((loaded < maxLength) && (offset < 3)) {
-                        _unaccountedCount = (_unaccountedCount << 8) + stream[loaded++];
+                        _storage = (_storage << 8) + stream[loaded++];
                         offset++;
                     }
 
-                    while ((loaded < maxLength) && ((offset - 3) < static_cast<uint16_t>(_unaccountedCount))) {
+                    while ((loaded < maxLength) && ((offset - 3) < static_cast<uint16_t>(_storage))) {
                         _value += static_cast<char>(stream[loaded++]);
                         offset++;
                     }
 
-                    if ((offset >= 3) && (static_cast<uint16_t>(offset - 3) == _unaccountedCount)) {
+                    if ((offset >= 3) && (static_cast<uint16_t>(offset - 3) == _storage)) {
                         offset = 0;
-                        _scopeCount |= ((_scopeCount & QuoteFoundBit) ? SetBit : (_value == NullTag ? NullBit : SetBit));
+                        _flagsAndCounters |= ((_flagsAndCounters & QuoteFoundBit) ? SetBit : (_value == NullTag ? NullBit : SetBit));
                     }
                 }
 
@@ -1970,76 +2082,20 @@ namespace Core {
             }
 
         private:
-            bool IsValidEscapeSequence(char current) const
-            {
-                ASSERT(MatchLastCharacter(_value, '\\') == true);
-                // Any character may be escaped using \uXXXX. The serlializer should escape
-                // control chars with values less that 0x1F using this convention. Also serializer
-                // should change '"' '\' '\n' '\t' '\f' '\r' '\f' to
-                // '\''"' '\''\' '\''n' '\''t' '\''f' '\''r' '\''f' and deserisalizer has to change tham back
-                return (current == '"') || (EscapeKeyLookupTable.find(current) != EscapeKeyLookupTable.end());
-            }
-
-            enum class EscapeSequenceAction {
-                NOTHING,
-                COLLAPSE,
-                REPLACE
-            };
-
-            char GetEscapeSequenceValue(const char current) const
-            {
-                char value = 0;
-                const auto index = EscapeKeyLookupTable.find(current);
-                if (index != EscapeKeyLookupTable.end()) {
-                    value = index->second;
-                }
-
-                return value;
-            }
-
-            EscapeSequenceAction GetEscapeSequenceAction(const char current) const
-            {
-
-                EscapeSequenceAction action = EscapeSequenceAction::COLLAPSE;
-                const auto index = EscapeKeyLookupTable.find(current);
-                if (index != EscapeKeyLookupTable.end()) {
-                    action = EscapeSequenceAction::REPLACE;
-                } else if((current == '\"') && (_scopeCount & DepthCountMask)) {
-                    action = EscapeSequenceAction::NOTHING;
-                }
-                return action;
-            }
+            std::string _default;
+            std::string _value;
 
-            bool IsEscapeSequenceValue(const char current, char& convertedValue) const
-            {
-                bool result = false;
-                for (const auto& index : EscapeKeyLookupTable) {
-                    if (index.second == current) {
-                        convertedValue = index.first;
-                        result = true;
-                        break;
-                    }
-                }
+            mutable uint32_t _storage;
 
-                return result;
-            }
-            enum class ScopeBracket : bool {
-                CURLY_BRACKET = 0,
-                SQUARE_BRACKET = 1
-            };
-
-            std::string _default;
             // The value stores the following BITS:
-            // | 4 |  5 |         23          |
-            // FFFFDDDDDSSSSSSSSSSSSSSSSSSSSSSS
+            // | 8 | 2 |  3  |  3  |
+            //   F   U   LLL   III
             // Where:
-            // F are flags bits (Null, Set etc.)
-            // D are depth value bits
-            // S bits keep scope stack.
-            // This constrains the maximal depth of the opaque object to be 23.
-            uint32_t _scopeCount;
-            mutable uint32_t _unaccountedCount;
-            std::string _value;
+            // F are flags bits (See statics at the beginning of the class)
+            // U is unused
+            // L Length of the bytes under process (8)
+            // I Index to the written bytes (8).
+            mutable uint16_t _flagsAndCounters;
         };
 
         class EXTERNAL Buffer : public IElement, public IMessagePack {
@@ -2420,9 +2476,9 @@ namespace Core {
             void Null(const bool enabled)
             {
                 if (enabled == true)
-                    _state |= UNDEFINED;
+                    _state |= (UNDEFINED|SET);
                 else
-                    _state &= ~UNDEFINED;
+                    _state &= ~(UNDEFINED|SET);
             }
 
             bool IsSet() const override
@@ -2461,7 +2517,7 @@ namespace Core {
                 if (offset == 0) {
 
                     if (_parser.IsNull() == true) {
-                        _state = UNDEFINED;
+                        _state = (UNDEFINED|SET);
                     } else if (_parser.IsSet() == true) {
                         // Looks like we parsed the value. Lets see if we can find it..
                         Core::EnumerateType<ENUMERATE> converted(_parser.Value().c_str(), false);
@@ -2470,8 +2526,9 @@ namespace Core {
                             _value = converted.Value();
                             _state = SET;
                         } else {
-                            _state = UNDEFINED;
+                            _state = (SET|UNDEFINED);
                             TRACE_L1(_T("Unknown enum value: %s"), _parser.Value().c_str());
+                            error = Error{ "Unknown enum value: " +  _parser.Value()};
                         }
                     } else {
                         error = Error{ "Invalid enum" };
@@ -2736,7 +2793,7 @@ namespace Core {
 
                 inline uint32_t Count() const
                 {
-                    return (_container == nullptr ? 0 : _container->size());
+                    return (_container == nullptr ? 0 : static_cast<uint32_t>(_container->size()));
                 }
 
             private:
@@ -3233,7 +3290,13 @@ namespace Core {
 
             void Reset()
             {
-                _data.clear();
+                JSONElementList::const_iterator index = _data.begin();
+
+                // As long as we did not find a set element, continue..
+                while (index != _data.end()) {
+                    index->second->Clear();
+                    index = _data.erase(index);
+                }
             }
 
             void Add(const TCHAR label[], IElement* element)
@@ -4211,7 +4274,6 @@ namespace Core {
             void Clear()
             {
                 Reset();
-                _elements.clear();
             }
             string GetDebugString(int indent = 0) const;
 
@@ -4357,7 +4419,7 @@ namespace Core {
 
                 } while ((loaded == size) && (offset != 0));
 
-                return (offset == 0);
+                return (error.IsSet() == false);
             }
 
             bool ToString(const Core::ProxyType<INSTANCEOBJECT>& receptor, string& value)
@@ -4382,6 +4444,70 @@ namespace Core {
         private:
             char _buffer[SIZE];
         };
+
+        template <typename JSONOBJECT>
+        class LabelType : public JSONOBJECT {
+        private:
+            LabelType(const LabelType<JSONOBJECT>&) = delete;
+            LabelType<JSONOBJECT>& operator=(const LabelType<JSONOBJECT>) = delete;
+
+        public:
+            LabelType()
+                : JSONOBJECT()
+            {
+            }
+            ~LabelType() override = default;
+
+        public:
+            static const char* Id()
+            {
+                return (__ID<JSONOBJECT>());
+            } 
+            virtual const char* Label() const
+            {
+                return (LabelType<JSONOBJECT>::Id());
+            }
+            void Clear() {
+                __Clear();
+            }
+
+        private:
+            HAS_MEMBER(Id, hasID);
+
+            typedef hasID<JSONOBJECT, const char* (JSONOBJECT::*)()> TraitID;
+
+            template <typename TYPE = JSONOBJECT>
+            static inline typename Core::TypeTraits::enable_if<LabelType<TYPE>::TraitID::value, const char*>::type __ID()
+            {
+                return (JSONOBJECT::Id());
+            }
+
+            template <typename TYPE = JSONOBJECT>
+            static inline typename Core::TypeTraits::enable_if<!LabelType<TYPE>::TraitID::value, const char*>::type __ID()
+            {
+                static std::string className = (Core::ClassNameOnly(typeid(JSONOBJECT).name()).Text());
+
+                return (className.c_str());
+            }
+
+            // -----------------------------------------------------
+            // Check for Clear method on Object
+            // -----------------------------------------------------
+            HAS_MEMBER(Clear, hasClear);
+
+            template <typename TYPE = JSONOBJECT>
+            inline typename Core::TypeTraits::enable_if<hasClear<TYPE, void (TYPE::*)()>::value, void>::type
+                __Clear()
+            {
+                TYPE::Clear();
+            }
+            template <typename TYPE = JSONOBJECT>
+            inline typename Core::TypeTraits::enable_if<!hasClear<TYPE, void (TYPE::*)()>::value, void>::type
+                __Clear()
+            {
+            }
+        };
+
     } // namespace JSON
 } // namespace Core
 } // namespace WPEFramework
diff --git a/Source/core/Serialization.cpp b/Source/core/Serialization.cpp
index 8f8b5902..1f872710 100644
--- a/Source/core/Serialization.cpp
+++ b/Source/core/Serialization.cpp
@@ -294,5 +294,113 @@ namespace Core {
 
         return (index);
     }
+
+    bool CodePointToUTF16(const uint32_t codePoint, uint16_t& lowPart, uint16_t& highPart) {
+
+        bool translated = true;
+
+        // Do we need to adapt the CodePoint for UTF16 ?
+        if (codePoint <= 0xFFFF) {
+            // Nope no need to re-encode, just send as is..
+            lowPart = codePoint;
+            highPart = 0;
+        }
+        else {
+            // Yes it is bigger than 16 bits..
+            uint32_t adjustedCodePoint = codePoint - 0x10000;
+
+            // According to the specification the code point can not exceed 20 bits than..
+            if (adjustedCodePoint >= 0xFFFFF) {
+                lowPart = 0x20; // It becomes a SPACE
+                highPart = 0x00;
+                translated = false;
+            }
+            else {
+                // Time to re-encode the HigPart and the LowPart..
+                lowPart = (adjustedCodePoint & 0x3FF) | 0xDC00;
+                highPart = ((adjustedCodePoint >> 10) & 0x3FF) | 0xD800;
+            }
+        }
+
+        return (translated);
+    }
+    bool UTF16ToCodePoint(const uint16_t lowPart, const uint16_t highPart, uint32_t& codePoint) {
+        bool translated = true;
+        if (highPart == 0) {
+            codePoint = lowPart;
+        }
+        else if (((lowPart & 0xFC00) == 0xDC00) && ((highPart & 0xFC00) == 0xD800)) {
+            codePoint = ((lowPart & 0x03FF) | ((highPart & 0x03FF) << 10)) + 0x10000;
+        }
+        else {
+            codePoint = 0x20; // It becomes a SPACE
+            translated = false;
+        }
+
+        return (translated);
+    }
+
+    int8_t ToCodePoint(const TCHAR* data, const uint8_t length,  uint32_t& codePoint) {
+
+        bool invalid = false;
+        #ifdef _UNICODE
+        static_assert(sizeof(TCHAR) != sizeof(char), "UTF16 to code point needs an implementation")
+        #else
+        uint32_t header = static_cast<uint16_t>(*data & 0xFF);
+        uint8_t following = (header < 0b11000000 ? 0 :
+            header < 0b11100000 ? 1 :
+            header < 0b11110000 ? 2 :
+            header < 0b11111000 ? 3 :
+            header < 0b11111100 ? 4 : 5);
+
+        // Get the bits of the indicator (ranges from 7 bits to 1)
+        if (following == 0) {
+            codePoint = header & 0x7F;
+        }
+        else {
+            codePoint = header & ((1 << (7 - following)) - 1);
+
+            // all right shit in the other bits..
+            for (uint8_t index = 1; (index <= following) && (index <= length); index++) {
+                codePoint = (codePoint << 6) | (data[index] & 0x3F);
+                invalid = invalid | ((data[index] & 0b11000000) != 0b10000000);
+            }
+        }
+        #endif
+
+        return (invalid ? -(following + 1) : (following + 1));
+    }
+    int8_t FromCodePoint(uint32_t codePoint, TCHAR* data, const uint8_t length) {
+        #ifdef _UNICODE
+        static_assert(sizeof(TCHAR) != sizeof(char), "UTF16 to code point needs an implementation")
+        #else
+        uint8_t following = (codePoint <= 0x0000007F ? 0 :
+            codePoint <= 0x000007FF ? 1 :
+            codePoint <= 0x0000FFFF ? 2 :
+            codePoint <= 0x001FFFFF ? 3 :
+            codePoint <= 0x03FFFFFF ? 4 : 5);
+        uint32_t shifter = codePoint;
+
+        // Get the bits of the indicator (ranges from 7 bits to 1)
+        if (following == 0) {
+            *data = (codePoint & 0x7F);
+        }
+        else {
+            // Just start shiftin out all easy bits..
+            for (uint8_t index = following; index > 0; index--) {
+                if (index < length) {
+                    data[index] = (shifter & 0x3F) | 0x80;
+                }
+                shifter = shifter >> 6;
+            }
+
+            // Now contruct a proper preamble..
+            data[0] = (~((1 << (7 - following)) - 1)) | (shifter & 0x3F);
+        }
+        #endif
+
+        return (following + 1);
+    }
+
 }
 } // namespace Core
diff --git a/Source/core/Serialization.h b/Source/core/Serialization.h
index 732396b5..1d15889d 100644
--- a/Source/core/Serialization.h
+++ b/Source/core/Serialization.h
@@ -265,6 +265,20 @@ namespace Core {
 
     uint16_t EXTERNAL FromString(const string& newValue, uint8_t object[], uint16_t& length, const TCHAR* ignoreList = nullptr);
 
+    //------------------------------------------------------------------------
+    // Codepoint: Operations to extract and convert code points.
+    //------------------------------------------------------------------------
+
+    // If false is returned, the conversion could not take place, in stead the result will indicate the codepoint 
+    // of SPACE.
+    bool EXTERNAL CodePointToUTF16(const uint32_t codePoint, uint16_t& lowPart, uint16_t& highPart);
+    bool EXTERNAL UTF16ToCodePoint(const uint16_t lowPart, const uint16_t highPart, uint32_t& codePoint);
+
+    // Negative return value indicates the length added but during the conversion something failed. It s not a
+    // valid code point or UTF8/16 sata stream.
+    int8_t EXTERNAL ToCodePoint(const TCHAR* data, const uint8_t length, uint32_t& codePoint);
+    int8_t EXTERNAL FromCodePoint(uint32_t codePoint, TCHAR* data, const uint8_t length);
+
     namespace Serialize {
         template <typename TEXTTERMINATOR, typename HANDLER>
         class ParserType {
-- 
2.25.1

