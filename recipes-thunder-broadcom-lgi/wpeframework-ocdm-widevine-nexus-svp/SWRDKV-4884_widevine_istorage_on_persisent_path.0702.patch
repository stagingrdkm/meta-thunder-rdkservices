2025.09.12 Hridhya Narayanan (hnarayanan.ext@libertyglobal.com)
[ONEM-41930] Broadcom patch on widevine istorage on persistent path

--- git/MediaSession.h	2025-07-02 16:13:58.571839480 -0400
+++ git/MediaSession.h	2025-06-26 18:09:17.174495357 -0400
@@ -45,6 +45,7 @@

 #pragma once

+#include <plugins/IShell.h>
 #include <interfaces/IDRM.h>

 #include <cdm.h>
--- git/MediaSystem.cpp	2025-06-27 10:58:11.549854795 -0400
+++ git/MediaSystem.cpp	2025-07-02 16:13:33.404306621 -0400
@@ -141,6 +141,19 @@
         Config config;
         config.FromString(configline);

+        { // Set a base path for IStorage such as cert.bin and usgtable.bin
+            string basePath;
+            if( shell->PersistentPath().back() == '/' ) {
+                basePath = string(shell->PersistentPath() + "wv.storage");
+            } else {
+                basePath = string(shell->PersistentPath() + "/wv.storage");
+            }
+
+            TRACE_L1("BasePath %s\n", basePath.c_str());
+            Core::Directory(basePath.c_str()).CreatePath();
+            _host.SetBasePath(basePath);
+        }
+
         // Set client info that denotes this as the test suite:
         if (config.Product.IsSet() == true) {
             client_info.product_name = config.Product.Value();
@@ -180,6 +193,7 @@

         // widevine::Cdm::DeviceCertificateRequest cert_request;

+#if 0 // No need to preload because of IStorage reading and writing from files at a persisent path
         if (config.Certificate.IsSet() == true) {
             Core::DataElementFile dataBuffer(config.Certificate.Value(), Core::File::USER_READ);

@@ -189,6 +203,7 @@
                 _host.PreloadFile(_certificateFilename,  std::string(reinterpret_cast<const char*>(dataBuffer.Buffer()), dataBuffer.Size()));
             }
         }
+#endif

 #if 0 // Move WideVine initialization out of constructor
         if (widevine::Cdm::kSuccess == widevine::Cdm::initialize(
--- git/HostImplementation.h	2025-06-27 09:25:59.393389169 -0400
+++ git/HostImplementation.h	2025-07-01 16:54:58.820286295 -0400
@@ -105,7 +105,10 @@

 public:

-  void PreloadFile(const std::string& filename, string&& filecontent);
+  void PreloadFile(const std::string& filename, string&& filecontent); /* deprecated */
+  void SetBasePath(const std::string& basepath);
+  bool readFromeFile(const std::string& name, std::string* data);
+  bool writeToFile(const std::string& name, const std::string& data);

   // widevine::Cdm::IStorage implementation
   // ---------------------------------------------------------------------------
@@ -127,7 +130,8 @@

 private:
   WPEFramework::Core::TimerType<Timer> _timer;
-  StorageMap _files;
+  StorageMap _cache;
+  string _basepath;
 };

 } // namespace CDMi
--- git/HostImplementation.cpp	2025-06-27 09:16:45.996029091 -0400
+++ git/HostImplementation.cpp	2025-07-02 16:59:23.300173078 -0400
@@ -44,6 +44,7 @@
 */

 #include "HostImplementation.h"
+#include <fstream>

 using namespace widevine;
 using namespace WPEFramework;
@@ -55,36 +56,96 @@
   , widevine::Cdm::IClock()
   , widevine::Cdm::ITimer()
   , _timer(Core::Thread::DefaultStackSize(),  _T("widevine"))
-  , _files() {
+  , _basepath("")
+  , _cache() {
 }

 HostImplementation::~HostImplementation() {
 }

+void HostImplementation::SetBasePath(const std::string& basepath) {
+  TRACE_L1("basepath %s", basepath.c_str());
+  _basepath = basepath;
+}
+
 void HostImplementation::PreloadFile(const std::string& filename, string&& filecontent ) {
-  _files.emplace(filename, filecontent);
+  _cache.emplace(filename, filecontent);
+}
+
+bool HostImplementation::readFromeFile(const std::string& name, std::string* data) {
+  struct stat Stat;
+  string filePath(_basepath + '/' + name);
+  if (stat(filePath.c_str(), &Stat) < 0)
+    return false;
+
+  std::ifstream File(filePath, std::ios::binary | std::ios::in);
+  data->resize(Stat.st_size);
+  File.read(&(*data)[0], data->size());
+  return true;
+}
+
+bool HostImplementation::writeToFile(const std::string& name, const std::string& data) {
+  string filePath(_basepath + '/' + name);
+  try
+  {
+    std::ofstream File(filePath, std::ios::binary | std::ios::out);
+    File.write(data.data(), data.size());
+    return true;
+  }
+  catch (...)
+  {
+    return false;
+  }
 }
+
 // widevine::Cdm::IStorage implementation
 // ---------------------------------------------------------------------------
 /* virtual */ bool HostImplementation::read(const std::string& name, std::string* data) {
-  StorageMap::iterator it = _files.find(name);
-  bool ok = it != _files.end();
-  TRACE_L1("read file: %s: %s", name.c_str(), ok ? "ok" : "fail");
-  if (!ok) return false;
-  *data = it->second;
-  return true;
+  StorageMap::iterator it = _cache.find(name);
+  bool ok = it != _cache.end();
+  TRACE_L1("read: %s: cache %s", name.c_str(), ok ? "ok" : "fail");
+  if (ok) {
+    TRACE_L1("name %s read from cache", name.c_str());
+    *data = it->second;
+    return true;
+  }
+
+  TRACE_L1("name %s read from file", name.c_str());
+  if(readFromeFile(name, data))
+  {
+      TRACE_L1("name %s read and update cache %d", name.c_str(), data->size());
+      _cache.emplace(name, std::string(reinterpret_cast<const char*>(data->data()), data->size()));
+      return true;
+  } else {
+      TRACE_L1("name %s not found!", name.c_str());
+      return false;
+  }
 }

 /* virtual */ bool HostImplementation::write(const std::string& name, const std::string& data) {
-  TRACE_L1("write file: %s", name.c_str());
-  _files[name] = data;
-  return true;
+  TRACE_L1("write: %s", name.c_str());
+  _cache[name] = data;
+  if(writeToFile(name, data)) {
+      TRACE_L1("sucess to write back %s.", name.c_str());
+      return true;
+  } else {
+      TRACE_L1("fail to write back %s!", name.c_str());
+      return false;
+  }
 }

 /* virtual */ bool HostImplementation::exists(const std::string& name) {
-  StorageMap::iterator it = _files.find(name);
-  bool ok = it != _files.end();
+  StorageMap::iterator it = _cache.find(name);
+  bool ok = it != _cache.end();
   TRACE_L1("exists? %s: %s", name.c_str(), ok ? "true" : "false");
+  if(ok) {
+    TRACE_L1("name %s cache hit", name.c_str());
+    return true;
+  }
+
+  string filePath(_basepath + '/' + name);
+  ok = access(filePath.c_str(), F_OK) == 0;
+  TRACE_L1("name %s cache miss, check file at %s, ok %d", name.c_str(), filePath.c_str(), ok);
   return ok;
 }

@@ -92,24 +153,95 @@
   TRACE_L1("remove: %s", name.c_str());
   if (name.empty()) {
     // If no name, delete all files (see DeviceFiles::DeleteAllFiles())
-    _files.clear();
-  } else {
-    _files.erase(name);
+    TRACE_L1("remove: all cache");
+    _cache.clear();
+
+    { // Remove all files under a base path
+      DIR *Directory = opendir(_basepath.c_str());
+      if (Directory == NULL)
+        return false;
+
+      struct dirent *Entry;
+      while (Entry = readdir(Directory), Entry != NULL) {
+        string filePath(_basepath + '/' + Entry->d_name);
+        TRACE_L1("remove %s", filePath.c_str());
+        unlink(filePath.c_str());
+      }
+
+      closedir(Directory);
+    }
+    return true;
+  }
+
+  // When name contains a wild card
+  if (name.find("*") != string::npos) {
+    TRACE_L1("remove %s with wildcard", name);
+    DIR *Directory = opendir(_basepath.c_str());
+    if (Directory == NULL)
+      return false;
+
+    struct dirent *Entry;
+    while (Entry = readdir(Directory), Entry != NULL) {
+      if (fnmatch(name.c_str(), Entry->d_name, 0) == 0) {
+        StorageMap::iterator it = _cache.find(Entry->d_name);
+        if(it != _cache.end()) {
+          TRACE_L1("remove %s from cache", Entry->d_name);
+          _cache.erase(Entry->d_name);
+        }
+        string filePath(_basepath + '/' + Entry->d_name);
+        TRACE_L1("remove %s", filePath.c_str());
+        unlink(filePath.c_str());
+      }
+    }
+
+    closedir(Directory);
+    return true;
+  }
+
+  // A specific name
+  StorageMap::iterator it = _cache.find(name);
+  if(it != _cache.end()) {
+      TRACE_L1("remove %s from cache", name);
+      _cache.erase(name);
   }
+
+  string filePath(_basepath + '/' + name);
+  TRACE_L1("remove %s", filePath.c_str());
+  unlink(filePath.c_str());
   return true;
 }

 /* virtual */ int32_t HostImplementation::size(const std::string& name) {
-  StorageMap::iterator it = _files.find(name);
-  if (it == _files.end()) return -1;
-  return it->second.size();
+  StorageMap::iterator it = _cache.find(name);
+  if (it != _cache.end()) {
+    TRACE_L1("name %s cache hit, size %d", name.c_str(), it->second.size());
+    return it->second.size();
+  }
+
+  struct stat Stat;
+  string filePath(_basepath + '/' + name);
+  if (stat(filePath.c_str(), &Stat) < 0) {
+    TRACE_L1("name %s not found", name.c_str());
+    return -1;
+  } else {
+    TRACE_L1("name %s found, size %d", name.c_str(), Stat.st_size);
+    return Stat.st_size;
+  }
 }

 /* virtual */ bool HostImplementation::list(std::vector<std::string>* names) {
+  DIR *Directory = opendir(_basepath.c_str());
+  if (Directory == NULL)
+    return false;
+
   names->clear();
-  for (StorageMap::iterator it = _files.begin(); it != _files.end(); it++) {
-      names->push_back(it->first);
+  struct dirent *Entry;
+  while (Entry = readdir(Directory), Entry != NULL) {
+    TRACE_L1("name %s add to list", Entry->d_name);
+    names->push_back(Entry->d_name);
   }
+
+  closedir(Directory);
   return true;
 }

